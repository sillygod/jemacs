#+TITLE: unarrange.el
#+PROPERTY: header-args:emacs-lisp :tangle ./jemacs-unarrange.el :mkdirp yes

* setup

  #+begin_src emacs-lisp
    ;;; mycraft --- Summary  -*- lexical-binding: t; -*-
    ;;; Copyright (C) 2020 mycraft maintainers
    ;;; Author: Jing
    ;;; package --- mycraft
    ;;; Commentary:

    ;;; Code:


  #+end_src

* winner mode
  By default, you will not go back to the original window layout when you exit the ediff mode

  #+begin_src emacs-lisp
    (use-package winner
      :commands (winner-undo))
  #+end_src

* dired

  pres =S-RET= will perform dired-find-file-other-window

  #+begin_src emacs-lisp :tangle no
    (use-package all-the-icons-dired
      :hook (dired-mode . all-the-icons-dired-mode)
      :config
      (setq all-the-icons-dired-monochrome nil)
      (set-face-attribute 'all-the-icons-dired-dir-face nil :foreground "#FF8822"))
  #+end_src

  #+begin_src emacs-lisp
    (use-package nerd-icons-dired
      :hook
      (dired-mode . nerd-icons-dired-mode))
  #+end_src

* esup
  a profiling tool for evaludating the performance of emacs' startup
  #+begin_src emacs-lisp
    (use-package esup
      :defer t
      :init
      (setq esup-depth 0))
  #+end_src

* svg-lib

  #+begin_src emacs-lisp
    (use-package svg-lib
      :defer 1)
  #+end_src

* pixel scroll

  #+begin_src emacs-lisp
    (use-package pixel-scroll
      :straight (:type built-in)
      :after evil
      :config
      (defun my-evil-adjust-cursor (&optional _)
        "Move point one character back if at the end of a non-empty line.
    This behavior is controlled by `evil-move-beyond-eol'."
        (and (not evil-move-beyond-eol)
             (not (bolp)) ;; a workaround
             ;; https://github.com/emacs-evil/evil/issues/1778
             (eolp)
             (= (point)
                (save-excursion
                  (evil-move-end-of-line)
                  (point)))
             (evil-move-cursor-back t)))
      (with-eval-after-load 'evil
        (advice-add 'evil-adjust-cursor :override 'my-evil-adjust-cursor))
      (pixel-scroll-precision-mode 1)
      (setq fast-but-imprecise-scrolling t))
  #+end_src

* command-log-mode
  this will log the keys you press in another buffer
  #+begin_src emacs-lisp
    (use-package command-log-mode
      :commands command-log-mode)
  #+end_src

* rainbow-mode
  #+begin_src emacs-lisp
    (use-package rainbow-mode
      :defer t)
  #+end_src

* rainbow-delimiters
  make parenthesis colorful and easier to distinguish
  #+begin_src emacs-lisp
    (use-package rainbow-delimiters
      :hook (prog-mode . rainbow-delimiters-mode))
  #+end_src

* highlight parentheses
  hightlight the current parenthesis' scope

  #+begin_src emacs-lisp
    (use-package highlight-parentheses
      :hook (prog-mode . highlight-parentheses-mode))
  #+end_src

* polymode

  https://polymode.github.io/installation/

  #+begin_src emacs-lisp
    (use-package polymode
      :defer t)

    (use-package poly-ansible
      :defer t)
  #+end_src

* terraform

  https://github.com/kgrotel/terraform-ts-mode
  terraform ts mode?

  #+begin_src emacs-lisp
    (use-package terraform-mode
      :defer t)
  #+end_src

* solidity

  #+begin_src emacs-lisp
    (use-package solidity-mode
      :straight
      (:host github :repo "ethereum/emacs-solidity" :files ("*.el"))
      :custom
      (solidity-comment-style 'slash)
      :init
      (require 'solidity-mode))
  #+end_src

* devdocs

  search thing under point [[https://devdocs.io/][devdocs]]

  #+begin_src emacs-lisp
    (eval `(use-package devdocs
             :defer t
             :straight (:local-repo ,(concat home-dir "local/devdocs"))))

  #+end_src

* jlight
  #+begin_src emacs-lisp
    (eval `(use-package jlight
                 :defer t
                 :straight (:local-repo ,(concat home-dir "local/jlight"))))
  #+end_src

* jworkspace
  #+begin_src emacs-lisp
    (eval `(use-package jworkspace
                 :defer t
                 :straight (:local-repo ,(concat home-dir "local/jworkspace"))))
  #+end_src
* counsel-jq-yq

  #+begin_src emacs-lisp
    (eval `(use-package jq-yq
             :defer t
             :straight (:local-repo ,(concat home-dir "local/jq-yq"))))

  #+end_src

* consult yas

  #+begin_src emacs-lisp
    (eval `(use-package consult-yas
             :defer t
             :straight (:local-repo ,(concat home-dir "local/consult-yas"))))
  #+end_src

* dired sort

  #+begin_src emacs-lisp
    (eval `(use-package dired-sort
             :defer t
             :after (evil)
             :straight (:local-repo ,(concat home-dir "local/dired-sort"))
             :init
             (dired-sort-setup)))
  #+end_src

* hl-todo mode

  TODO: https://github.com/coldnew/coldnew-emacs#highlight-fixme-todo

  #+begin_src emacs-lisp
    (use-package hl-todo
      :defer t
      :hook
      ;; (text-mode . hl-todo-mode) text-mode is the parent of org-mode
      (prog-mode . hl-todo-mode)
      :config
      (setq hl-todo-highlight-punctuation ":")
      (setq hl-todo-keyword-faces
            `(
              ("TODO" warning bold)
              ("FIXME" error bold)
              ("HACK" font-lock-constant-face bold)
              ("NOTE" success bold)
              ("BUG" error bold)
              ("DEPRECATED" font-lock-doc-face bold))))
  #+end_src

* spawn ollama or cps

  #+begin_src emacs-lisp
    (defun spwan-ollama-web-and-open ()
      (interactive)
      (let* ((default-directory "~/Desktop/ollama-webui/backend/")
             (buf (get-buffer-create (concat "*" "ollama-web" "*")))
             (proc (get-buffer-process buf)))
        (unless proc
          (start-process "ollama-web" buf "bash" "start.sh"))
        (xwidget-webkit-browse-url "http://localhost:8080")))


    (defun spawn-calibre-web-and-open ()
      "Spawn a cps process in background and open it on browser.
    https://github.com/janeczku/calibre-web"
      (interactive)
      (let* ((buf (get-buffer-create (concat "*" "calibre-web" "*")))
             (proc (get-buffer-process buf)))

        (unless proc
          (start-process "calibre-web" buf "cps"))
        (xwidget-webkit-browse-url "http://localhost:8083")))
  #+end_src

* so-long
  prevent emacs from freezing when encountering a very long line

  #+begin_src emacs-lisp
    (use-package so-long
      :defer 1
      :straight (:type built-in)
      :custom
      (so-long-threshold 20000)
      :config
      (setq large-hscroll-threshold 50)
      (setq long-line-threshold 8000)
      (setq bidi-inhibit-bpa t)
      (setq bidi-display-reordering nil)
      (global-so-long-mode 1))
  #+end_src

* rime-emacs

  make rime input method work seamlessly with emacs

  you can download the rime from the github
  brew install --cask squirrel


  #+begin_src bash :tangle no
    curl -L -o rime.tar.bz2 https://github.com/rime/librime/releases/download/1.11.2/rime-5b09f35-macOS-universal.tar.bz2
    tar -xf rime.tar.bz2 -C ~/.emacs.d/emacs-home/librime
  #+end_src

  #+begin_src emacs-lisp
    (use-package rime
      :defer 1
      :straight (rime :type git
                      :host github
                      :repo "DogLooksGood/emacs-rime"
                      :files ("*.el" "Makefile" "lib.c"))
      :custom
      (rime-librime-root (expand-file-name "librime/dist" user-emacs-directory))
      (rime-emacs-module-header-root (shell-command-to-string "echo -n $(brew --prefix)/include"))
      (rime-user-data-dir "/Users/jing/Library/Rime/")
      (rime-inline-ascii-trigger 'shift-l)
      (default-input-method "rime")
      (rime-show-candidate 'posframe)

      :config
      (setq rime-translate-keybindings
            '("C-f" "C-b" "C-n" "C-p" "C-g" "<left>" "<return>" "TAB" "<tab>" "<right>" "<up>" "<down>" "<prior>" "<next>" "<delete>"))
      (define-key rime-mode-map (kbd "C-'") 'rime-inline-ascii))
  #+end_src

* dictonary relevant packages
  there two package are not usable right now.

  TODO:
  now, emacs has a builtin dictionary features
  ex. dictionary-lookup-definition
  take it into consideration?

  #+begin_src emacs-lisp
    (use-package define-word
      :defer t)

    (use-package powerthesaurus
      :defer t)
  #+end_src

* notification

  #+begin_src emacs-lisp
    (use-package alert
      :commands alert
      :config
      (if (system-is-mac!)
          (setq alert-default-style 'osx-notifier)))
  #+end_src

* ebook reader
  #+begin_src emacs-lisp
    (use-package nov
      :defer t
      :mode ("\\.epub\\'" . nov-mode))
  #+end_src

  https://github.com/chenyanming/nov-xwidget  another choice

* uuidgen
  #+begin_src emacs-lisp
    (use-package uuidgen
      :defer t)
  #+end_src

* docker
  #+begin_src emacs-lisp
    (use-package docker
      :defer t)

    (use-package docker-tramp
      :defer t)

    (use-package dockerfile-mode
      :defer t)
  #+end_src

* nginx
  #+begin_src emacs-lisp
    (use-package nginx-mode
      :defer t)
  #+end_src

* jsonnet-mode

  This is depended on the jsonnet binary.

  #+begin_src sh
    go get github.com/google/go-jsonnet/cmd/jsonnet
  #+end_src

  #+begin_src emacs-lisp
    (use-package jsonnet-mode
      :defer t)
  #+end_src

* conf-mode
  #+begin_src emacs-lisp
    (use-package conf-mode
      :defer t
      :mode ("\\(Cargo.lock\\|\\poetry\\.lock\\)\\'" . conf-toml-mode)) ;; a macro to generate auto-mode-list
  #+end_src

* jinja2-mode
  to research why there should append a suffix ='= for the mod
  the :config will be run after trigger autoload function
  change the tab behavior of jinja2 mode by =indent-line-function=

  #+begin_src emacs-lisp
    (use-package jinja2-mode
      :defer t
      :init
      (add-hook 'jinja2-mode-hook
                #'(lambda ()
                    (set (make-local-variable 'indent-line-function) 'insert-tab)))
      :mode ("\\.j2\\'" . jinja2-mode))

  #+end_src

* makefile-mode

  makefile uses =tab= strictly to identify the target, and other things

   #+begin_src emacs-lisp
     (use-package make-mode
       :defer t
       :init
       (add-hook 'makefile-mode-hook
                 #'(lambda ()
                     (setq-local indent-tabs-mode t))))

  #+end_src

* racket-mode
  #+begin_src emacs-lisp
    (use-package racket-mode
      :defer t)
  #+end_src

* smartparens

  Decide to use this package to auto balance the parens
  NOTE: we should put hook in the =:init=
  If we put this in the =:config=, it will perform add these hook after lazy-loading.
  That means we will not get it auto turn on when we enter one of the following program mode

  =:init= before trigger
  =:config= after trigger

  #+begin_src emacs-lisp
    (use-package smartparens
      :defer 0
      :commands (smartparens-mode)
      :hook
      (js-mode . smartparens-mode)
      (go-mode . smartparens-mode)
      (rust-mode . (lambda () (sp-local-pair 'rust-mode "'" nil :actions nil)
                     (smartparens-mode))) ;;; don't pair lifetime specifiers
      (html-mode . smartparens-mode)
      (python-mode . smartparens-mode)
      (emacs-lisp-mode . smartparens-mode)
      :config
      (require 'smartparens-config))
  #+end_src

* yasnippet

  =(yas-reload-all)= will rebuild the snippets, This will be trigger when enable yas-xx-mode

  #+begin_src emacs-lisp
    (use-package yasnippet
      :defer 1
      :config
      (add-to-list 'yas-snippet-dirs (expand-file-name "snippets" home-dir))
      ;; (yas-global-mode 1)
      (yas-minor-mode 1))

    (use-package yasnippet-snippets
      :defer t
      :after yasnippet)

  #+end_src

* helpful
  make help description more readble
  #+begin_src emacs-lisp
    (use-package helpful
      :bind
      ([remap describe-command] . helpful-callable)
      ([remap describe-function] . helpful-function)
      ([remap describe-variable] . helpful-variable)
      ([remap describe-symbol] . helpful-symbol)
      ([remap describe-keymap] . helpful-varaible)
      ([remap describe-key] . helpful-key))
  #+end_src

* winum
  #+begin_src emacs-lisp
    (use-package winum
      :defer 0
      :config
      (winum-mode))
  #+end_src

* systemd

  encounter an *issue: Company backend ’t’ could not be initialized*
  #+begin_src emacs-lisp
    (use-package systemd
      :defer t)
  #+end_src

* flycheck mode

  https://github.com/emacs-languagetool

  #+begin_src emacs-lisp
    (use-package flycheck
      :commands (flycheck-mode)
      :init
      (add-hook 'prog-mode-hook 'flycheck-mode)
      (add-hook 'text-mode-hook 'flycheck-mode)
      :custom
      (flycheck-highlighting-mode 'lines)
      (flycheck-indication-mode '())
      (flycheck-emacs-lisp-load-path 'inherit)
      (flycheck-javascript-eslint-executable "./node_modules/.bin/eslint")
      :config
      (add-hook 'org-src-mode-hook #'(lambda ()
                                       (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))))
  #+end_src

* json-mode & yaml-mode

  use =make-local-variable= to set buffer local variable.

  #+begin_src emacs-lisp
    (use-package json-mode
      :defer t)

    (use-package yaml-mode
      :defer t
      :mode (("\\.\\(yml\\|yaml\\)\\'" . yaml-mode)
             ("Procfile\\'" . yaml-mode))
      :init
      (add-hook 'yaml-mode-hook #'(lambda ()
                                    (set (make-local-variable 'tab-width) 2)
                                    (set (make-local-variable 'evil-shift-width) 2)
                                    (set (make-local-variable 'indent-line-function) 'my-yaml-indent-line)))
      :config
      ;; (with-eval-after-load 'evil
      ;;   (evil-define-key 'normal yaml-mode-map (kbd "=") 'yaml-indent-line))
      (with-eval-after-load 'flycheck
        (when (listp flycheck-global-modes)
          (add-to-list 'flycheck-global-modes 'yaml-mode))))

    (use-package yaml-ts-mode
      :defer t
      :mode (("\\.\\(yml\\|yaml\\)\\'" . yaml-mode)
             ("Procfile\\'" . yaml-mode))
      :init
      (add-hook 'yaml-ts-mode-hook #'(lambda ()
                                    (set (make-local-variable 'tab-width) 2)
                                    (set (make-local-variable 'evil-shift-width) 2)
                                    (set (make-local-variable 'indent-line-function) 'my-yaml-indent-line)))
      :config
      ;; (with-eval-after-load 'evil
      ;;   (evil-define-key 'normal yaml-mode-map (kbd "=") 'yaml-indent-line))
      (with-eval-after-load 'flycheck
        (when (listp flycheck-global-modes)
          (add-to-list 'flycheck-global-modes 'yaml-mode))))

  #+end_src


** experiment tree-sitter

   tree-sitter requires emacs built with dynamic modules (due to c bindings library) supports.
   (functionp 'module-load)

   #+begin_src emacs-lisp :tangle no
     (use-package tree-sitter
       :config
       (global-tree-sitter-mode))

     (use-package tree-sitter-langs
       :defer t
       :hook
       (tree-sitter-after-on . tree-sitter-hl-mode))
   #+end_src

   =now tree sitter are builtin in emacs 29 but it's not matured= However, I still decide to adopt the builtin functions.

   auto setup for tree sitter inspired from
   https://github.com/renzmann/treesit-auto/blob/main/treesit-auto.el

   #+begin_src emacs-lisp
     (use-package treesit
       :straight (:type built-in)
       :commands (treesit-install-language-grammar treesit-install-all-languages)
       :init
       (setq treesit-language-source-alist
             '((bash . ("https://github.com/tree-sitter/tree-sitter-bash"))
               (c . ("https://github.com/tree-sitter/tree-sitter-c"))
               (cpp . ("https://github.com/tree-sitter/tree-sitter-cpp"))
               (common-lisp "https://github.com/theHamsta/tree-sitter-commonlisp")
               (elisp "https://github.com/Wilfred/tree-sitter-elisp")
               (css . ("https://github.com/tree-sitter/tree-sitter-css"))
               (go . ("https://github.com/tree-sitter/tree-sitter-go"))
               (html . ("https://github.com/tree-sitter/tree-sitter-html"))
               (helm . ("https://github.com/ngalaiko/tree-sitter-go-template" "master" "dialects/helm/src"))
               (javascript . ("https://github.com/tree-sitter/tree-sitter-javascript"))
               (json . ("https://github.com/tree-sitter/tree-sitter-json"))
               (lua . ("https://github.com/Azganoth/tree-sitter-lua"))
               (make . ("https://github.com/alemuller/tree-sitter-make"))
               (ocaml . ("https://github.com/tree-sitter/tree-sitter-ocaml" "ocaml/src" "ocaml"))
               (python . ("https://github.com/tree-sitter/tree-sitter-python"))
               (php . ("https://github.com/tree-sitter/tree-sitter-php"))
               (tsx . ("https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src"))
               (typescript . ("https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src"))
               (ruby . ("https://github.com/tree-sitter/tree-sitter-ruby"))
               (rust . ("https://github.com/tree-sitter/tree-sitter-rust"))
               (sql . ("https://github.com/m-novikov/tree-sitter-sql"))
               (yaml "https://github.com/tree-sitter-grammars/tree-sitter-yaml")
               (toml . ("https://github.com/tree-sitter/tree-sitter-toml"))
               (vue . ("https://github.com/tree-sitter-grammars/tree-sitter-vue"))
               (zig . ("https://github.com/GrayJack/tree-sitter-zig"))))
       :config
       (let ((langs (mapcar 'car treesit-language-source-alist)))
         (dolist (lang langs)
           (let ((ts-mode (intern (concat (symbol-name lang) "-ts-mode")))
                 (name-mode (intern (concat (symbol-name lang) "-mode"))))
             (if (and (fboundp ts-mode) (treesit-ready-p lang t))
                 (add-to-list 'major-mode-remap-alist `(,name-mode . ,ts-mode)))))))

     (defun treesit-install-all-languages ()
       "Install all languages specified by `treesit-language-source-alist'."
       (interactive)
       (let ((languages (mapcar 'car treesit-language-source-alist)))
         (dolist (lang languages)
           (let ((ts-mode (intern (concat (symbol-name lang) "-ts-mode")))
                 (name-mode (intern (concat (symbol-name lang) "-mode"))))

             (treesit-install-language-grammar lang)
             (message "`%s' parser was installed." lang)
             (sit-for 0.75)))))
   #+end_src

   https://github.com/emacs-tree-sitter/treesit-fold

   #+begin_src emacs-lisp
     (use-package treesit-fold
       :after (evil)
       :straight (treesit-fold :type git :host github :repo "emacs-tree-sitter/treesit-fold")
       :config
       (push '(block . (treesit-fold-range-seq -1 1)) (alist-get 'python-mode treesit-fold-range-alist))
       (push '(block . (treesit-fold-range-seq -1 1)) (alist-get 'python-ts-mode treesit-fold-range-alist))
       (add-to-list 'evil-fold-list
                    '((treesit-fold-mode)
                      :toggle treesit-fold-toggle
                      :open treesit-fold-open
                      :close treesit-fold-close
                      :open-rec treesit-fold-open-recursively
                      :open-all treesit-fold-open-all
                      :close-all treesit-fold-close-all))
       (global-treesit-fold-mode))
   #+end_src

   an optional structure navigation package
   https://github.com/mickeynp/combobulate

   #+begin_src emacs-lisp
     (with-eval-after-load 'yaml
       (with-eval-after-load 'json
         (defun get-config-nesting-paths ()
           "Get out all the nested paths in a config file."
           (let* ((query (pcase major-mode
                           ('json-mode "(object (pair (string (string_content) @key) (_)) @item)")
                           ('yaml-mode "(block_mapping_pair (flow_node) @key (_)) @item")))
                  (root-node (tsc-root-node tree-sitter-tree))
                  (query (tsc-make-query tree-sitter-language query))
                  (matches (tsc-query-matches query root-node #'tsc--buffer-substring-no-properties))
                  (prev-node-ends '(0)) ;; we can get away with just end as the list is sorted
                  (current-key-depth '())
                  (item-ranges (seq-map (lambda (x)
                                          (let ((item (seq-elt (cdr x) 0))
                                                (key (seq-elt (cdr x) 1)))
                                            (list (tsc-node-text (cdr key))
                                                  (tsc-node-range (cdr key))
                                                  (tsc-node-range (cdr item)))))
                                        matches)))
             (mapcar (lambda (x)
                       (let* ((current-end (seq-elt (cadr (cdr x)) 1))
                              (parent-end (car prev-node-ends))
                              (current-key (car x)))
                         (progn
                           (if (> current-end parent-end)
                               (mapcar (lambda (x)
                                         (if (> current-end x)
                                             (progn
                                               (setq prev-node-ends (cdr prev-node-ends))
                                               (setq current-key-depth (cdr current-key-depth)))))
                                       prev-node-ends))
                           (setq current-key-depth (cons current-key current-key-depth))
                           (setq prev-node-ends (cons current-end prev-node-ends))
                           (list (reverse current-key-depth) (seq-elt (cadr x) 0)))))
                     item-ranges)))

         (defun imenu-config-nesting-path ()
           "Return config-nesting paths for use in imenu"
           (mapcar (lambda (x)
                     (cons (string-join (car x) ".") (cadr x)))
                   (get-config-nesting-paths)))

         (add-hook 'json-mode-hook (lambda () (setq imenu-create-index-function #'imenu-config-nesting-path)))
         (add-hook 'yaml-mode-hook (lambda () (setq imenu-create-index-function #'imenu-config-nesting-path)))))
   #+end_src

   #+begin_src emacs-lisp
     (defun json-get-path (current-node output)
       "Get path to json value at cursor position.  CURRENT-NODE is a treesit-node.
     OUTPUT is parsed path list."
       (let* ((parent-node (treesit-node-parent current-node)))
         (if parent-node
             (progn
               (when (equal (treesit-node-type parent-node) "array")
                 (let ((index -1)
                       (child (treesit-node-child parent-node 0)))
                   (while (and child (not (treesit-node-eq current-node child)))
                     (when (treesit-node-check child 'named)
                       (setq index (+ index 1)))
                     (setq child (treesit-node-next-sibling child)))
                   (setq output (push index output))))
               (when (equal (treesit-node-type current-node) "pair")
                 (setq output (push (treesit-node-text (treesit-node-child current-node 0)) output)))
               (json-get-path parent-node output))
           output)))

     (defun json-print-path-js ()
       "Copy json path in JavaScript format."
       (interactive)
       (let (json-path)
         (dolist (elt (json-get-path (treesit-node-at (point)) '()) json-path)
           (when (stringp elt)
             (let* ((trimmed-elt (string-trim elt "\"" "\"")))
               (if (string-match-p "-" trimmed-elt)
                   (setq json-path (concat json-path "[" trimmed-elt "]"))
                 (setq json-path (concat json-path "." trimmed-elt)))))
           (when (numberp elt)
             (setq json-path (concat json-path "[" (number-to-string elt) "]"))))
         (message json-path)
         (kill-new json-path)))

   #+end_src

* cmake
  #+begin_src emacs-lisp
    (use-package cmake-mode
      :defer t
      :mode (("CMakeLists\\.txt\\'" . cmake-mode) ("\\.cmake\\'" . cmake-mode)))
  #+end_src

* lua
  #+begin_src emacs-lisp
    (use-package lua-mode
      :mode (("\\.lua\\'" . lua-mode))
      :defer t)
  #+end_src

* calibre

  #+begin_src emacs-lisp
    (use-package calibredb
      :defer t
      :config
      (setq calibredb-format-all-the-icons t)
      (setq calibredb-root-dir "~/OneDrive/calibre")
      (setq calibredb-db-dir (expand-file-name "metadata.db" calibredb-root-dir)))
  #+end_src

* common lisp or emacs lisp

  TODO: maybe I neeed the better go to definition function like the spacemacs's implementation

  #+begin_src emacs-lisp
    (use-package slime
      :defer t
      :init
      (setq inferior-lisp-program "sbcl"))

    (use-package elisp-slime-nav
      :defer t
      :init
      (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
        (add-hook hook 'elisp-slime-nav-mode)))

    (use-package lispy
      :init
      (setq lispy-key-theme '(special c-digits))
      :custom
      (lispy-x-default-verbosity 1)
      :hook ((common-lisp-mode . lispy-mode)
             (emacs-lisp-mode . lispy-mode)
             (scheme-mode . lispy-mode))
      :config
      (with-eval-after-load 'evil-matchit
        (lispy-define-key lispy-mode-map (kbd "%") 'lispy-different)
        (lispy-define-key lispy-mode-map (kbd "d") 'lispy-kill)))

  #+end_src

  a minimum lisp like structural editing

  #+begin_src emacs-lisp :tangle no
    (repeat-mode 1)
    (defvar structural-edit-map
      (let ((map (make-sparse-keymap)))
        (pcase-dolist (`(,k . ,f)
                       '(("u" . backward-up-list)
                         ("f" . forward-sexp)
                         ("b" . backward-sexp)
                         ("d" . down-list)
                         ("k" . kill-sexp)
                         ("n" . sp-next-sexp)
                         ("p" . sp-previous-sexp)
                         ("K" . sp-kill-hybrid-sexp)
                         ("]" . sp-forward-slurp-sexp)
                         ("[" . sp-backward-slurp-sexp)
                         ("}" . sp-forward-barf-sexp)
                         ("{" . sp-backward-barf-sexp)
                         ("C" . sp-convolute-sexp)
                         ("J" . sp-join-sexp)
                         ("S" . sp-split-sexp)
                         ("R" . sp-raise-sexp)
                         ("\\" . indent-region)
                         ("/" . undo)
                         ("t" . transpose-sexps)
                         ("x" . eval-defun)))
          (define-key map (kbd k) f))
        map))

    (map-keymap
     (lambda (_ cmd)
       (put cmd 'repeat-map 'structural-edit-map))
     structural-edit-map)
  #+end_src

* dumb-jump

  a jump to definition with search tool (ag, rg)

  #+begin_src emacs-lisp
    (defvar-local dumb-temp-search-directory nil)

    (defun my-dumb-jump-get-project-root (filepath)
      "a very hack way to customize the way to search the project of dumb-jump"
      (let ((search-directory (or dumb-temp-search-directory
                                  (if (project-current nil)
                                  (project-root (project-current nil))
                                (read-directory-name "Start from directory: ")))))
        (setq-local dumb-temp-search-directory search-directory)
        search-directory))

    (advice-add 'dumb-jump-get-project-root :override #'my-dumb-jump-get-project-root)

    (use-package dumb-jump
      :init
      (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
      :custom
      (dumb-jump-selector 'completing-read)
      (dumb-jump-prefer-searcher 'rg)
      (dumb-jump-force-searcher 'rg)
      :defer t)
  #+end_src

* language server protocol mode

  run =company-diag= to check what the company-backend is being used.
  =(setq lsp-keymap-prefix "SPC m")= this will only affect the display info of whichkey.

  #+begin_src emacs-lisp

    (defun get-xref-find-backends ()
      (let (backends
            backend)
        (dolist (f xref-backend-functions)
          (when (functionp f)
            (setq backend (funcall f))
            (when backend
              (cl-pushnew (funcall f) backends))))
        (reverse backends)))

    (defun my-xref--create-fetcher (input kind arg)
      "Return an xref list fetcher function.

    It revisits the saved position and delegates the finding logic to
    the xref backend method indicated by KIND and passes ARG to it."
      (let* ((orig-buffer (current-buffer))
             (orig-position (point))
             (backends (get-xref-find-backends))
             (method (intern (format "xref-backend-%s" kind))))
        (lambda ()
          (save-excursion
            ;; Xref methods are generally allowed to depend on the text
            ;; around point, not just on their explicit arguments.
            ;;
            ;; There is only so much we can do, however, to recreate that
            ;; context, given that the user is free to change the buffer
            ;; contents freely in the meantime.
            (when (buffer-live-p orig-buffer)
              (set-buffer orig-buffer)
              (ignore-errors (goto-char orig-position)))
            (let (xrefs)
              (cl-dolist (backend backends)
                (ignore-errors
                  (setq xrefs (funcall method backend arg))
                  (when xrefs
                    (cl-return))))
              (unless xrefs
                (xref--not-found-error kind input))
              xrefs)))))



  #+end_src

  TODO: deprecate lsp, I decide to adopt elgot.

  #+begin_src emacs-lisp :tangle no
    (use-package lsp-bridge
      :defer t
      :straight (:host github :repo "manateelazycat/lsp-bridge" :files ("*.el" "")))
  #+end_src

  https://github.com/mohkale/consult-eglot/
  #+begin_src emacs-lisp

    (use-package eglot
      :defer t
      :init
      (setq read-process-output-max (* 1024 1024))
      (setq eglot-stay-out-of '(xref imenu)) ;; imenu in go-mode will cause jsonrpc timeout
      (add-hook 'eglot--managed-mode-hook #'(lambda () (add-hook 'xref-backend-functions 'eglot-xref-backend nil t)))
      (add-hook 'python-ts-mode-hook (lambda ()
                                       (message "setup eglot")
                                       (when-let* ((venv-path (python-find-virtualenv)))
                                         (pyvenv-activate venv-path)

                                         ;; TODO:
                                         ;; assign a function to eglot-workspace-configuration instead of variable
                                         (setq-default eglot-workspace-configuration
                                                       `(:python.analysis
                                                         (:stubPath
                                                          ""
                                                          :useLibraryCodeForTypes
                                                          t
                                                          :autoSearchPaths
                                                          t
                                                          :autoImportCompletions
                                                          t
                                                          :diagnosticMode
                                                          "openFilesOnly")
                                                         :python
                                                         (:venvPath
                                                          ,(file-name-directory venv-path)
                                                          :venv
                                                          ,(file-name-nondirectory venv-path)
                                                          :pythonPath
                                                          ,(concat venv-path "/bin/python"))))

                                         (when (fboundp 'eglot-ensure)
                                           (flycheck-mode -1)
                                           (eglot-ensure)
                                           (add-hook 'xref-backend-functions 'dumb-jump-xref-activate nil t)
                                           (add-hook 'xref-backend-functions 'eglot-xref-backend nil t)))))
      (add-hook 'python-mode-hook (lambda ()
                                    (message "setup eglot")
                                    (when-let* ((venv-path (python-find-virtualenv)))
                                      (pyvenv-activate venv-path)

                                      ;; TODO:
                                      ;; assign a function to eglot-workspace-configuration instead of variable
                                      (setq-default eglot-workspace-configuration
                                                    `(:python.analysis
                                                      (:stubPath
                                                       ""
                                                       :useLibraryCodeForTypes
                                                       t
                                                       :autoSearchPaths
                                                       t
                                                       :autoImportCompletions
                                                       t
                                                       :diagnosticMode
                                                       "openFilesOnly")
                                                      :python
                                                      (:venvPath
                                                       ,(file-name-directory venv-path)
                                                       :venv
                                                       ,(file-name-nondirectory venv-path)
                                                       :pythonPath
                                                       ,(concat venv-path "/bin/python"))))

                                      (when (fboundp 'eglot-ensure)
                                        (flycheck-mode -1)
                                        (eglot-ensure)
                                        (add-hook 'xref-backend-functions 'dumb-jump-xref-activate nil t)
                                        (add-hook 'xref-backend-functions 'eglot-xref-backend nil t)))))
      :hook
      (rust-mode . eglot-ensure)
      (rust-ts-mode . eglot-ensure)
      (lua-mode . eglot-ensure)
      (dart-mode . eglot-ensure)
      (helm-mode . eglot-ensure)
      (js-mode . eglot-ensure)
      (js-ts-mode . eglot-ensure)
      (tsx-mode-hook . eglot-ensure)
      (typescript-ts-mode . eglot-ensure)
      (typescript-mode . eglot-ensure)
      (json-mode . eglot-ensure) ;; npm i -g vscode-langservers-extracted
      (json-ts-mode . eglot-ensure)
      (yaml-mode . eglot-ensure) ;; brew install yaml-language-server
      (yaml-ts-mode . eglot-ensure)
      (go-mode . eglot-ensure)
      (go-ts-mode . eglot-ensure)
      :custom
      (enable-local-variables t)
      ;; do I need this ? setting this to nil will cause -*- mode:xxx -*- not be performed. we'll manually run normal-mode.
      ;; For more detail, go to see the help doc of normal-mode
      (xref-search-program 'ripgrep)
      (eglot-events-buffer-size 0)
      (eglot-ignored-server-capabilities '(:hoverProvider
                                           :documentHighlightProvider))
      :config
      (advice-add #'xref--create-fetcher :override #'my-xref--create-fetcher)
      ;; this make evil go to definition works normally like xref-find-definitions
      (setq xref-prompt-for-identifier (append xref-prompt-for-identifier '(evil-goto-definition)))
      (fset #'jsonrpc--log-event #'ignore)

      (add-to-list 'eglot-server-programs '(python-mode . ("pyright-langserver" "--stdio")))
      (add-to-list 'eglot-server-programs '(helm-mode "helm_ls" "serve"))
      (add-to-list 'eglot-server-programs '(dart-mode . ("dart" "language-server" "--client-id" "emacs.eglot-dart" "--client-version" "1.2" "--protocol" "lsp")))
      (add-to-list 'eglot-server-programs '(solidity-mode . ("nomicfoundation-solidity-language-server" "--stdio")))
      (add-to-list 'eglot-server-programs
                   '((rust-ts-mode rust-mode) .
                     ("rustup" "run" "stable" "rust-analyzer" :initializationOptions (:check (:command "clippy"))))))
  #+end_src

  NOTE: it's not compatible with the latest eglot
  #+begin_src emacs-lisp :tangle no
    (use-package eglot-booster
      :straight
      (:host github :repo "jdtsmith/eglot-booster" :files ("*.el"))
      :after eglot
      :config (eglot-booster-mode))
  #+end_src

* wgrep mode
  #+begin_src emacs-lisp
    (use-package wgrep
      :after evil
      :custom
      (wgrep-auto-save-buffer t)
      :commands
      (wgrep-finish-edit
       wgrep-finish-edit
       wgrep-abort-changes
       wgrep-abort-changes)
      :init
      (evil-define-key 'normal wgrep-mode-map (kbd "<escape>") 'wgrep-exit)
      (evil-define-key 'normal wgrep-mode-map (kbd ", ,") 'wgrep-finish-edit)
      (evil-define-key 'normal wgrep-mode-map (kbd ", k") 'wgrep-abort-changes))
  #+end_src

* multiple-cursors
  it will save the command behavior applied on the multiple cursor to a file named .mc-lists.el.
  By default, it's path is =~/.emacs.d/.mc-lists.el= and I customize the storing path already.
  Research how evil-mc customize the multiple-cursor

  https://github.com/magnars/multiple-cursors.el#unknown-commands

  #+begin_src emacs-lisp
    (use-package multiple-cursors
      :custom
      (mc/always-run-for-all t)
      :commands
      (mc/edit-lines
       mc/mark-all-like-this
       mc/add-cursor-on-click
       mc/mark-next-like-this
       mc/mark-previous-like-this))

    (use-package evil-mc
      :after evil
      :config
      (global-evil-mc-mode 1))
  #+end_src

  #+begin_src emacs-lisp
    (use-package iedit
      :commands
      (iedit-restrict-region)
      :config
      (define-key iedit-occurrence-keymap-default
        (kbd "<escape>") #'(lambda () (interactive) (iedit-mode -1))))
  #+end_src

* general

  provide a spacemacs leader like ux.

  #+begin_src emacs-lisp
    (use-package general
      :after (which-key evil)
      :config
      (defconst leader-key "SPC")
      (defconst major-mode-leader-key "SPC m")
      (defconst major-mode-leader-key-shortcut ",")
      (defconst emacs-state-leader-key "M-m")
      (defconst emacs-state-major-mode-leader-key "M-m m")

      (setq my-leader-def-prop
            '(:key leader-key :states (normal visual motion)))

      (setq my-leader-def-emacs-state-prop
            '(:key emacs-state-leader-key :state (emacs)))

      ;; below are for major mode
      (setq my-local-leader-def-prop
            '(:key major-mode-leader-key :states (normal visual motion)))

      (setq my-local-leader-def-alias-prop
            '(:key major-mode-leader-key-shortcut :states (normal visual motion)))

      (setq my-local-leader-def-emacs-state-prop
            '(:key emacs-state-major-mode-leader-key :states (emacs)))
      ;; NOTE: '() the element inside will be symbol

      ;; NOTE: keysmaps override is to make general-define-key to be global scope
      ;; No need to set this one (evil-make-overriding-map dired-mode-map 'normal)
      (message "DEBUG: !! general init")

      (transient-define-prefix window-transient ()
        "Window operation transient."
        :transient-suffix 'transient--do-stay
        [["Resize"
          ("[" "shrink h" my-shrink-window-horizontally)
          ("]" "enlarge h" my-enlarge-window-horizontally)
          ("{" "shrink v" my-shrink-window)
          ("}" "enlarge v" my-enlarge-window)
          ("=" "balance" balance-windows)
          ("m" "maximize" jworkspace-toggle-maximize-window)
          ("q" "quit" transient-quit-all)
          ("<escape>" "quit" transient-quit-all)
          ]
         ["Select"
          ("h" "left" evil-window-left)
          ("l" "right" evil-window-right)
          ("k" "up" evil-window-up)
          ("j" "down" evil-window-down)
          ("1" "window 1" winum-select-window-1)
          ("2" "window 2" winum-select-window-2)
          ("3" "window 3" winum-select-window-3)
          ("4" "window 4" winum-select-window-4)
          ("5" "window 5" winum-select-window-5)
          ("6" "window 6" winum-select-window-6)
          ]
         ["Move"
          ("L" "left" evil-window-move-far-right)
          ("H" "right" evil-window-move-far-left)
          ("J" "down" evil-window-move-very-bottom)
          ("K" "up" evil-window-move-very-top)
          ]
         ["Action"
          ("/" "split vertically" evil-window-vsplit)
          ("-" "split horizontally" evil-window-split)
          ("d" "delete window" delete-window)
          ]
         ])


      (with-eval-after-load 'org-roam
        (transient-define-prefix org-roam-transient ()
          "Org roam operation transient."
          :transient-suffix 'transient--do-exit
          [["Action"
            ("a" "add alias for node" org-roam-alias-add)
            ;; this is used for whening the name is conflict. It mostly happens in the header name
            ("c" "create node" org-id-get-create)
            ("i" "insert" org-roam-node-insert)
            ("f" "find file" org-roam-node-find)
            ("d" "dailies" org-roam-dailies-goto-today)
            ("l" "back link buffer" org-roam-buffer-toggle)
            ("g" "graph" my-org-roam-ui-open)
            ("r" "db refresh" my-refresh-org-roam-db-cache)
            ("t" "add tag" org-roam-tag-add)
            ("<escape>" "quit" transient-quit-all)
            ("q" "quit" transient-quit-all)]
           ]))


      (transient-define-prefix buffer-transient ()
        "Buffer operation transient."
        :transient-suffix 'transient--do-stay
        [["Move"
          ("n" "next buffer" next-buffer)
          ("p" "prev buffer" previous-buffer)
          ("b" "project buffers" consult-project-buffer)
          ("B" "buffer lists" consult-buffer)
          ("o" "other window" other-window)
          ("q" "quit" transient-quit-all)]
         ["Action"
          ("d" "delete" kill-this-buffer)
          ]])

      (transient-define-prefix text-transient ()
        "Text operation transient."
        :transient-suffix 'transient--do-stay
        [["Action"
          ("j" "+" text-scale-increase)
          ("k" "-" text-scale-decrease)
          ("0" "reset" (lambda () (interactive) (text-scale-adjust 0)))
          ("<escape>" "quit" transient-quit-all)
          ("q" "quit" transient-quit-all)]
         ])

      (with-eval-after-load 'git-timemachine
        (transient-define-prefix git-timemachine-transient ()
          "Git timemachien transient."
          :transient-suffix 'transient--do-stay
          [["Action"
            ("p" "prev" git-timemachine-show-previous-revision)
            ("n" "next" git-timemachine-show-next-revision)
            ("s" "search" git-timemachine-show-revision-fuzzy)
            ("g" "magit goto commit" git-timemachine-show-commit :transient transient--do-exit)
            ("c" "copy revision" git-timemachine-kill-revision :transient transient--do-exit)
            ("<escape>" "quit" git-timemachine-quit :transient transient--do-exit)
            ("q" "quit" git-timemachine-quit :transient transient--do-exit)]
           ]))

      (transient-define-prefix toggle-mode-transient ()
        "Toggle mode transient."
        :transient-suffix 'transient--do-stay
        [["Action"
          ("d" "distraction mode" writeroom-mode)
          ("r" "rainbow mode" rainbow-mode)
          ("w" "whitespace-mode" whitespace-mode)
          ("t" "theme" consult-theme :transient transient--do-exit)
          ("v" "visual line mode" visual-line-mode)
          ("f" "check spell" flyspell-mode)
          ("<escape>" "quit" transient-quit-all)
          ("q" "quit" transient-quit-all)]
         ])


      (with-eval-after-load 'emmet-mode
        (evil-define-key 'insert emmet-mode-keymap (kbd "TAB") 'my-emmet-expand))

      ;; unbind some keybinding in the package 'evil-org
      (with-eval-after-load 'evil-org
        ;;  org-agenda-redo
        ;;  make org agenda enter the motion state
        ;;  I don't the original state
        (evil-set-initial-state 'org-agenda-mode 'motion)
        ;; TODO: research about this evilified-state-evilify-map

        (evil-define-key 'motion org-agenda-mode-map
          (kbd "j") 'org-agenda-next-line
          "t" 'org-agenda-todo
          "I" 'org-agenda-clock-in          ; Original binding
          "O" 'org-agenda-clock-out         ; Original binding
          (kbd "<return>") 'org-agenda-goto
          (kbd "k") 'org-agenda-previous-line
          (kbd "s") 'org-save-all-org-buffers))

      (with-eval-after-load 'org

        ;; define key open-thing-at-point with enter
        (evil-define-key 'normal org-mode-map (kbd "<return>") 'org-open-at-point)
        (evil-define-key 'normal prog-mode-map (kbd "<return>") 'org-open-at-point))

      (with-eval-after-load 'org-capture
        (evil-define-key 'normal org-capture-mode-map
          (kbd ", ,") 'org-capture-finalize
          (kbd ", k") 'org-capture-kill
          (kbd ", w") 'org-capture-refile))

      ;; add shortcuts for org src edit mode
      (with-eval-after-load 'org-src
        (evil-define-key 'normal org-src-mode-map
          (kbd ", ,") 'org-edit-src-exit
          (kbd ", k") 'org-edit-src-abort))

      (with-eval-after-load 'with-editor
        (evil-define-key 'normal with-editor-mode-map
          (kbd ", ,") 'with-editor-finish
          (kbd ", k") 'with-editor-cancel))

      (evil-define-key 'visual 'global
        (kbd "g y") 'copy-region-and-base64-decode
        (kbd "g e") 'copy-region-and-urlencode)


      ;; keybinding for racket-mode
      (with-eval-after-load 'racket-mode
        (define-leader-key-map-for 'racket-mode
                                   "" "major mode" nil
                                   "x" "execute" nil
                                   "xx" "racket run" 'racket-run))

      ;; keybindings for some major modes
      ;; NOTE: consider to move these to the configuration of each major-mode?

      ;; keybinding for go-mode
      (with-eval-after-load 'go-ts-mode

        (define-leader-key-map-for 'go-ts-mode-map
                                   "" "major mode" nil
                                   "x" "execute" nil
                                   "xx" "go run" 'go-run-main
                                   "d" "debug" 'dap-hydra
                                   "e" "gomacro" 'gomacro-run)


        (evil-define-key 'normal go-mode-map (kbd "K") 'evil-smart-doc-lookup))

      (with-eval-after-load 'rust-mode

        (evil-define-key 'normal rust-mode-map (kbd "K") 'evil-smart-doc-lookup))

      ;; keybinding for python-mode
      (with-eval-after-load 'python

        (apply 'define-leader-key-map-for
               (list 'python-ts-mode-map
                     "" "major mode" '()

                     "x" "execute" nil
                     "xx" "python run" 'python-run-main
                     "h" "help" 'eldoc-box-eglot-help-at-point
                     "v" "workon env" 'workon-virtual-env-and-lsp
                     "d" "debug" 'dap-hydra)))

      (with-eval-after-load 'json-ts-mode
        (define-leader-key-map-for 'json-ts-mode-map
                                   "" "major mode" nil
                                   "l" "lookup" nil
                                   "ll" "snatch path" 'json-print-path-js
                                   "lj" "jq" 'consult-jq))

      (with-eval-after-load 'json-mode
        (define-leader-key-map-for 'json-mode-map
                                   "" "major mode" nil
                                   "l"  "lookup" nil
                                   "ll" "snatch path" 'json-print-path-js
                                   "lj" "jq" 'consult-jq))


      (with-eval-after-load 'yaml-ts-mode
        (define-leader-key-map-for 'yaml-ts-mode-map
                                   "" "major mode" nil
                                   "l" "lookup" nil
                                   "ly" "yq" 'consult-yq))


      (with-eval-after-load 'elisp-mode
        (define-leader-key-map-for 'emacs-lisp-mode-map
                                   "" "major mode" nil
                                   "e" "eval" nil
                                   "ef" "eval defun" 'eval-defun
                                   "eb" "eval buffer" 'eval-buffer
                                   "er" "eval region" 'eval-region ))

      (with-eval-after-load 'org
        (define-leader-key-map-for 'org-mode-map
                                   "" "major mode" nil

                                   "a" "org-agenda" 'org-agenda
                                   "," "org-ctrl-c-ctrl-c" 'org-ctrl-c-ctrl-c
                                   "'" "org-edit-special" 'org-edit-special

                                   "b" "babel" nil
                                   "bt" "tangle" 'org-babel-tangle

                                   "i" "insert" nil
                                   "il" "insert link" 'org-insert-link
                                   "it" "insert toc" 'org-insert-toc
                                   "is" "insert time section" 'insert-new-time-section-under-routine

                                   "e" "export" nil
                                   "ee" "org-export-dispatch" 'org-export-dispatch

                                   "n" "narrow" nil
                                   "ns" "narrow subtree" 'org-narrow-to-subtree
                                   "nN" "widen" 'widen

                                   "r" "org roam transient" 'org-roam-transient

                                   "s" "schedule" nil
                                   "ss" "org-schedule" 'org-schedule
                                   "sd" "org-deadline" 'org-deadline
                                   "st" "org-time-stamp" 'org-time-stamp

                                   "d" "org-download" nil
                                   "dc" "from clipboard" 'org-download-clipboard
                                   "ds" "from screenshot" 'org-download-screenshot

                                   "t" "toggles" nil
                                   "tl" "link display" 'org-toggle-link-display
                                   "ti" "inline image" 'org-link-preview))


      (define-leader-key-global
       "SPC" 'execute-extended-command
       "/" 'my-project-rg
       "v" 'er/expand-region
       "u" 'universal-argument
       "'" 'new-terminal
       "TAB" 'vterm-perform-last-command
       "?" 'describe-bindings)

      ;; which-key-replacement-alist
      ;; change the content of the above variable
      (define-leader-key-global
       "1" 'winum-select-window-1
       "2" '(winum-select-window-2 :which-key t)
       "3" '(winum-select-window-3 :which-key t)
       "4" '(winum-select-window-4 :which-key t)
       "5" '(winum-select-window-5 :which-key t)
       "6" '(winum-select-window-6 :which-key t)
       "7" '(winum-select-window-7 :which-key t)
       "8" '(winum-select-window-8 :which-key t)
       "9" '(winum-select-window-9 :which-key t))

      ;; need to find a way to add which-key hints
      ;; for the following window selection
      (push '(("\\(.*\\)1" . "winum-select-window-1") .
              ("\\11..9" . "select window 1..9"))
            which-key-replacement-alist)

      (define-leader-key-global
       "j" '(:ignore t :which-key "jump")
       "jw" '(avy-goto-char-timer :which-key "avy goto words")
       "ju" '(avy-jump-url :which-key "goto url")
       "jd" '(xref-find-definitions :which-key "goto definition") ;; limit the search area with the project root
       "jl" '(avy-goto-line :which-key "goto line")
       "ji" '(jump-in-buffer :which-key "imenu")
       "j(" '(check-parens :which-key "check-parens"))

      (define-leader-key-global
       "r" '(:ignore t :which-key "resume/register")
       "rk" '(consult-yank-pop :which-key "kill ring")
       "re" '(consult-register :which-key "evil register")

       "rm" '(:ignore t :which-key "mark ring")
       "rml" '(consult-mark :which-key "local mark ring")
       "rmg" '(consult-global-mark :which-key "global mark ring")

       "rl" '(vertico-repeat :which-key "minibuffer-resume"))

      (define-leader-key-global
       "a" '(:ignore t :which-key "applications")

       "aa" '(aider-transient-menu :which-key "aider-chat")

       "ad" '(docker t :which-key "docker")

       "al" '(:ignore t :which-key "lookup/dictionary")
       "ald" '(define-word :which-key "lookup definition")
       "alg" '(google-search :which-key "google search")
       "alx" '(open-with-xwidget :which-key "open with xwidget")

       "ao" '(:ignore t :which-key "org")
       "aor" '(org-roam-transient :which-key "org-roam-transient")
       "aog" '(:ignore t :which-key "goto")
       "aogj" '((lambda () (interactive) (find-file (expand-file-name "~/Dropbox/myorgs/journal"))) :which-key "journal note")
       "aogt" '((lambda () (interactive) (org-file-show-headings "~/Dropbox/myorgs/life_books_courses_programming/todo.org")) :which-key "todo note"))

      (define-leader-key-global
       "b" '(:ignore t :which-key "buffer")
       "bb" '(consult-project-buffer :which-key "project-list-buffer")
       "bd" '(kill-this-buffer :which-key "kill-buffer")
       "bB" '(consult-buffer :which-key "list-buffer")
       "bi" '(ibuffer :which-key "ibuffer")
       "bn" '(next-buffer :which-key "next-buffer")
       "bp" '(previous-buffer :which-key "previous-buffer")
       "bN" '(new-empty-buffer :which-key "new empty buffer")
       "b." '(buffer-transient :which-key "buffer transient"))

      (define-leader-key-global
       "c" '(:ignore t :which-key "comment/compile")
       "cl" '(comment-or-uncomment-lines :which-key "comment or uncomment"))

      (define-leader-key-global
       "e" '(:ignore t :which-key "errors")
       "el" '(toggle-flycheck-error-list :which-key "flycheck error list"))


      (define-leader-key-global
       "i" '(:ignore t :which-key "insert")
       "is" '(insert-yas :which-key "snippets")
       "it" '(insert-current-timestamp :which-key "timestamp")
       "iu" '(uuidgen :which-key "uuid4")
       "ip" '(insert-secure-random-password :which-key "random password"))

      (define-leader-key-global
       "l" '(:ignore t :which-key "layout")
       "ll" '(jworkspace-switch-workspace :which-key "switch layout")
       "lr" '(jworkspace-rename-workspace :which-key "rename layout")
       "ld" '(jworkspace-delete-workspace :which-key "delete layout"))

      (define-leader-key-global
       "n" '(:ignore t :which-key "narrow")
       "nf" '(narrow-to-defun :which-key "narrow to defun")
       "nr" '(narrow-to-region :which-key "narrow to region")
       "nw" '(widen :which-key "widen"))

      (define-leader-key-global
       "p" '(:ignore t :which-key "project")
       "pp" '(consult-switch-project :which-key "switch project")
       "pf" '(project-find-file :which-key "find-file"))

      (define-leader-key-global
       "s" '(:ignore t :which-key "search")
       "sc" '((lambda () (interactive) (evil-ex-nohighlight)(clear-highlight)) :which-key "clear highlight")
       "ss" '(consult-line :which-key "consult-line")
       "sS" '(consult-line-multi :which-key "consult-line-all"))

      (define-leader-key-global
       "g" '(:ignore t :which-key "git")
       "gi" '(magit-init :which-key "gagit init")
       "gb" '(:ignore t :which-key "blame")
       "gl" '(magit-list-repositories :which-key "magit list repos")
       "gbl" '(git-messenger:popup-message :which-key "this line")
       "gbb" '(magit-blame-addition :which-key "this buffer")
       "gs" '(magit-status :which-key "magit status")
       "gt" '((lambda () (interactive) (git-timemachine) (git-timemachine-transient)) :which-key "magit time machine"))

      (define-leader-key-global
       "k" '(:ignore t :which-key "kmacro")
       "ks" '(kmacro-start-macro-or-insert-counter :which-key "start macro/insert counter")
       "ke" '(kmacro-end-or-call-macro :which-key "end or run record")
       "kv" '(kmacro-view-macro-repeat :which-key "view last macro")
       "kn" '(kmacro-name-last-macro :which-key "name the last kmacro"))

      (define-leader-key-global
       "q" '(:ignore t :which-key "quit")
       "qq" '(save-buffers-kill-emacs :which-key "quit with saving buffer")
       "qr" '(restart-emacs :which-key "restart"))

      (define-leader-key-global
       "t"  '(:ignore t :which-key "toggles")
       "tm" '(toggle-mode-transient :which-key "toggle mode")
       "ti" '(toggle-input-method :which-key "toggle input method")
       "ts" '(text-transient :which-key "scale text"))

      (define-leader-key-global
       "w" '(:ignore t :which-key "windows")
       "wf" '(toggle-frame-fullscreen :which-key "toggle fullscreen")
       "ww" '(other-window :which-key "other-window")
       "wm" '(jworkspace-toggle-maximize-window :which-key "window maximized")
       "wM" '(toggle-frame-maximized :which-key "frame maximized")
       "wd" '(delete-window :which-key "delete window")
       "wh" '(evil-window-left :which-key "go to window left")
       "wl" '(evil-window-right :which-key "go to window right")
       "wk" '(evil-window-up :which-key "go to window up")
       "wr" '(rotate-windows-forward :which-key "rotate window")
       "wj" '(evil-window-down :which-key "go to window down")
       "wL" '(evil-window-move-far-right :which-key "move window to right side")
       "wH" '(evil-window-move-far-left :which-key "move window to left side")
       "wJ" '(evil-window-move-very-bottom :which-key "move window to bottom side")
       "wK" '(evil-window-move-very-top :which-key "move window to top side")

       "wg" '(switch-to-minibuffer-window :which-key "go to minibuffer")

       "w/" '(evil-window-vsplit :which-key "split vertically")
       "w-" '(evil-window-split :which-key "split horizontally")

       "w=" '(balance-windows :which-key "balance")
       "w[" '(my-shrink-window-horizontally :which-key "shrink h")
       "w]" '(my-enlarge-window-horizontally :which-key "enlarge h")
       "w{" '(my-shrink-window :which-key: "shrink v")
       "w}" '(my-enlarge-window :which-key: "enlarge v")

       "wF" '(make-frame :which-key "make frame")
       "wD" '(delete-frame :which-key "delete frame")
       "wo" '(other-frame :which-key "other frame")
       "w." '(window-transient :which-key "window transient"))

      (define-leader-key-global
       "x" '(:ignore t :which-key "texts")
       "xc" '(count-words-region :which-key "count-words-region")

       "xb" '(:ignore t :which-key "base64")
       "xbe" '(my-encode-region-base64 :which-key "base64-encode-region")
       "xbd" '(my-decode-region-base64 :which-key "base64-decode-region")

       "xs" '(send-text-and-move-to-project-vterm :which-key "send content to and focus on vterm"))

      (define-leader-key-global
       "f" '(:ignore t :which-key "files")
       "fe" '(:ignore t :which-key "emacs")
       "fed" '(my-find-dotfile :which-key "open config dotfile")
       "fy" '(copy-file-path :which-key "copy file path")
       "fd" '(dired-jump :which-key "dired")
       "fs" '(save-buffer :which-key "save file")
       "ft" '(rg-file-search :which-key "find dir or file")
       "fr" '(rename-current-buffer-file :which-key "rename file")
       "ff" '(find-file :which-key "find file"))

      (message "DEBUG: !! complete general setting"))
  #+end_src

* experimental popup frame

  we can spawn from the shell

  #+begin_src bash
    emacsclient -ne "(present (completing-read \"Open: \" '((\"a\" \"a-1\") (\"b\" \"b-2\") (\"c\" \"c-3\"))))"
  #+end_src

  M-x server-start ?

  #+begin_src emacs-lisp
    (defmacro present (&rest body)
      "Create a buffer with BUFFER-NAME and eval BODY in a basic frame."
      (declare (indent 1) (debug t))
      `(let* ((buffer (get-buffer-create (generate-new-buffer-name "*present*")))
              (frame (make-frame '((auto-raise . t)
                                   (top . 200)
                                   (height . 20)
                                   (width . 110)
                                   (internal-border-width . 20)
                                   (left . 0.33)
                                   (left-fringe . 0)
                                   (line-spacing . 3)
                                   (menu-bar-lines . 0)
                                   (minibuffer . only)
                                   (right-fringe . 0)
                                   (tool-bar-lines . 0)
                                   (undecorated . t)
                                   (unsplittable . t)
                                   (vertical-scroll-bars . nil)))))

         (raise-frame frame)
         (select-frame frame)
         (select-frame-set-input-focus frame)
         (with-current-buffer buffer
               (unwind-protect
                   ,@body
                   (delete-other-windows)
                   (delete-frame frame)
                   (kill-buffer buffer)
                   ))))
  #+end_src
* hydra replaced with transient

** +hydra+ motion (replaced with the builtin functions of transient)

   Originally, evil defines key =*= in motion-state with =evil-search-forward=

   #+begin_src emacs-lisp

     (with-eval-after-load 'transient

       (defun expand-and-highlight-region ()
         (interactive)
         (er--expand-region-1)
         (highlight-selected-word))

       (defun contract-and-highlight-region ()
         (interactive)
         (call-interactively 'er/contract-region)
         (highlight-selected-word))


       (defun evil-surround-region-utils (operation)
         ;; TODO: implement this one
         (interactive (evil-surround-interactive-setup))
         ;; (cond
         ;;  ((eq operation 'change)
         ;;   (call-interactively 'evil-surround-change))
         ;;  ((eq operation 'delete)
         ;;   (call-interactively 'evil-surround-delete))
         ;;  (t
         ;;   (evil-surround-setup-surround-line-operators)
         ;;   (evil-surround-call-with-repeat 'evil-surround-region))))

         (if (region-active-p)
             (evil-surround-setup-surround-line-operators)
           (evil-surround-call-with-repeat 'evil-surround-region)))


       (transient-define-prefix mark-transient ()
         "Swift kniffe for mark region."
         :transient-suffix 'transient--do-stay
         [["Match"
           ("v" "expand" expand-and-highlight-region)
           ("-" "contract" contract-and-highlight-region)
           ("r" "range" my-change-range)
           ("i" "toggle case sensitive" my-toggle-case-sensitive)
           ("n" "next" goto-next-highlighted-word)
           ("N" "prev" goto-prev-highlighted-word)
           ("q" "quit" transient-quit-all)
           ("<escape>" "quit" transient-quit-all)
           ]
          ["Search"
           ("s" "consult line" (lambda () (interactive) (consult-line (jlight-get-matched-thing))))
           ("/" "project search" my-project-rg)
           ]
          ["Edit"
           ("e" "iedit" my-iedit-mode :transient transient--do-exit)
           ("c" "change surround" evil-surround-region :transient transient--do-exit)
           ("o" "to org table" org-table-create-or-convert-from-region :transient transient--do-exit)
           ]
          ["Misc"
           ("t" "send to vterm" send-text-and-move-to-project-vterm :transient transient--do-exit)
           ]
          ])

       (defun my-toggle-case-sensitive ()
         (interactive)
         (setq-local case-fold-search (not case-fold-search))
         (highlight-selected-word (not case-fold-search)))

       (defun my-iedit-mode ()
         (interactive)
         (call-interactively 'iedit-mode)
         (iedit-restrict-region
          (jlight-get-startpoint-of-first-matched)
          (jlight-get-endpoint-of-last-matched)))

       (defun my-change-range ()
         (interactive)
         ;; TODO: implement change range function
         (iedit-restrict-region
          (ahs-current-plugin-prop 'start)
          (ahs-current-plugin-prop 'end)))


       (defun wrap-mark-operation ()
         (interactive)
         (unless (region-active-p)
           (er--expand-region-1))
         (highlight-selected-word (not case-fold-search))
         (mark-transient))

       (with-eval-after-load 'evil
         (evil-define-key '(normal motion) 'evil-motion-state-map
           (kbd "*") 'wrap-mark-operation)))
   #+end_src

* provide package

  #+begin_src emacs-lisp
    (provide 'jemacs-unarrange)
    ;;; jemacs-unarrange.el ends here
  #+end_src
