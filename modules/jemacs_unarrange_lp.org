#+TITLE: unarrange.el
#+PROPERTY: header-args:emacs-lisp :tangle ./jemacs-unarrange.el :mkdirp yes

* setup

  #+begin_src emacs-lisp
    ;;; mycraft --- Summary  -*- lexical-binding: t; -*-
    ;;; Copyright (C) 2020 mycraft maintainers
    ;;; Author: Jing
    ;;; package --- mycraft
    ;;; Commentary:

    ;;; Code:


  #+end_src

* winner mode
  By default, you will not go back to the original window layout when you exit the ediff mode

  #+begin_src emacs-lisp
    (use-package winner
      :commands (winner-undo))
  #+end_src

* dired

  pres =S-RET= will perform dired-find-file-other-window

  #+begin_src emacs-lisp
    (use-package all-the-icons-dired
      :hook (dired-mode . all-the-icons-dired-mode)
      :config
      (setq all-the-icons-dired-monochrome nil)
      (set-face-attribute 'all-the-icons-dired-dir-face nil :foreground "#FF8822"))
  #+end_src

* esup
  a profiling tool for evaludating the performance of emacs' startup
  #+begin_src emacs-lisp
    (use-package esup
      :defer t
      :init
      (setq esup-depth 0))
  #+end_src

* svg-lib

  #+begin_src emacs-lisp
    (use-package svg-lib
      :defer 1)
  #+end_src

* diminish
  #+begin_src emacs-lisp
    (use-package diminish :defer t)
  #+end_src

* command-log-mode
  this will log the keys you press in another buffer
  #+begin_src emacs-lisp
    (use-package command-log-mode
      :commands command-log-mode)
  #+end_src

* rainbow-mode
  #+begin_src emacs-lisp
    (use-package rainbow-mode
      :defer t)
  #+end_src

* rainbow-delimiters
  make parenthesis colorful and easier to distinguish
  #+begin_src emacs-lisp
    (use-package rainbow-delimiters
      :hook (prog-mode . rainbow-delimiters-mode))
  #+end_src

* highlight parentheses
  hightlight the current parenthesis' scope

  #+begin_src emacs-lisp
    (use-package highlight-parentheses
      :hook (prog-mode . highlight-parentheses-mode))
  #+end_src

* polymode

  https://polymode.github.io/installation/

  #+begin_src emacs-lisp
    (use-package polymode
      :defer t)

    (use-package poly-ansible
      :defer t)
  #+end_src

* terraform

  #+begin_src emacs-lisp
    (use-package terraform-mode
      :defer t)
  #+end_src

* devdocs

  search thing under point [[https://devdocs.io/][devdocs]]

  #+begin_src emacs-lisp
    (eval `(use-package devdocs
             :defer t
             :straight (:local-repo ,(concat home-dir "local/devdocs"))))

  #+end_src

* counsel-jq-yq

  #+begin_src emacs-lisp
    (eval `(use-package jq-yq
             :defer t
             :straight (:local-repo ,(concat home-dir "local/jq-yq"))))

  #+end_src

* dired sort

  #+begin_src emacs-lisp
    (eval `(use-package dired-sort
             :defer t
             :after (hydra evil)
             :straight (:local-repo ,(concat home-dir "local/dired-sort"))
             :init
             (dired-sort-setup)))
  #+end_src

* hl-todo mode

  TODO: https://github.com/coldnew/coldnew-emacs#highlight-fixme-todo

  #+begin_src emacs-lisp
    (use-package hl-todo
      :defer t
      :hook
      ;; (text-mode . hl-todo-mode) text-mode is the parent of org-mode
      (prog-mode . hl-todo-mode)
      :config
      (setq hl-todo-highlight-punctuation ":")
      (setq hl-todo-keyword-faces
            `(
              ("TODO" warning bold)
              ("FIXME" error bold)
              ("HACK" font-lock-constant-face bold)
              ("NOTE" success bold)
              ("BUG" error bold)
              ("DEPRECATED" font-lock-doc-face bold))))
  #+end_src

* so-long
  prevent emacs from freezing when encountering a very long line

  #+begin_src emacs-lisp
    (use-package so-long
      :defer 1
      :config
      (global-so-long-mode 1))
  #+end_src

* rime-emacs

  make rime input method work seamlessly with emacs

  you can download the rime from the github
  https://github.com/rime/librime/releases/download/1.7.2/rime-1.7.2-osx.zip

  #+begin_src emacs-lisp
    (use-package rime
      :defer 1
      :straight (rime :type git
                      :host github
                      :repo "DogLooksGood/emacs-rime"
                      :files ("*.el" "Makefile" "lib.c"))
      :custom
      (rime-librime-root (expand-file-name "librime/dist" user-emacs-directory))
      (rime-emacs-module-header-root "/usr/local/opt/emacs-plus@30/include/")
      (rime-user-data-dir "/Users/jing/Library/Rime/")
      (rime-inline-ascii-trigger 'shift-l)
      (default-input-method "rime")
      (rime-show-candidate 'posframe)

      :config
      (setq rime-translate-keybindings
            '("C-f" "C-b" "C-n" "C-p" "C-g" "<left>" "<return>" "TAB" "<tab>" "<right>" "<up>" "<down>" "<prior>" "<next>" "<delete>"))
      (define-key rime-mode-map (kbd "C-'") 'rime-inline-ascii))
  #+end_src

* dictonary relevant packages
  there two package are not usable right now.
  #+begin_src emacs-lisp
    (use-package define-word
      :defer t)

    (use-package powerthesaurus
      :defer t)
  #+end_src

* notification

  #+begin_src emacs-lisp
    (use-package alert
      :commands alert
      :config
      (if (system-is-mac!)
          (setq alert-default-style 'osx-notifier)))
  #+end_src

* ebook reader
  #+begin_src emacs-lisp
    (use-package nov
      :defer t
      :mode ("\\.epub\\'" . nov-mode))
  #+end_src

  https://github.com/chenyanming/nov-xwidget  another choice

* uuidgen
  #+begin_src emacs-lisp
    (use-package uuidgen
      :defer t)
  #+end_src

* docker
  #+begin_src emacs-lisp
    (use-package docker
      :defer t)

    (use-package docker-tramp
      :defer t)

    (use-package dockerfile-mode
      :defer t)
  #+end_src

* nginx
  #+begin_src emacs-lisp
    (use-package nginx-mode
      :defer t)
  #+end_src

* jsonnet-mode

  This is depended on the jsonnet binary.

  #+begin_src sh
    go get github.com/google/go-jsonnet/cmd/jsonnet
  #+end_src

  #+begin_src emacs-lisp
    (use-package jsonnet-mode
      :defer t)
  #+end_src

* conf-mode
  #+begin_src emacs-lisp
    (use-package conf-mode
      :defer t
      :mode ("\\(Cargo.lock\\|\\poetry\\.lock\\)\\'" . conf-toml-mode)) ;; a macro to generate auto-mode-list
  #+end_src

* jinja2-mode
  to research why there should append a suffix ='= for the mod
  the :config will be run after trigger autoload function
  change the tab behavior of jinja2 mode by =indent-line-function=

  #+begin_src emacs-lisp
    (use-package jinja2-mode
      :defer t
      :init
      (add-hook 'jinja2-mode-hook
                #'(lambda ()
                    (set (make-local-variable 'indent-line-function) 'insert-tab)))
      :mode ("\\.j2\\'" . jinja2-mode))

  #+end_src

* makefile-mode

  makefile uses =tab= strictly to identify the target, and other things

   #+begin_src emacs-lisp
     (use-package make-mode
       :defer t
       :init
       (add-hook 'makefile-mode-hook
                 #'(lambda ()
                     (setq-local indent-tabs-mode t))))

  #+end_src

* racket-mode
  #+begin_src emacs-lisp
    (use-package racket-mode
      :defer t)
  #+end_src

* smartparens

  Decide to use this package to auto balance the parens
  NOTE: we should put hook in the =:init=
  If we put this in the =:config=, it will perform add these hook after lazy-loading.
  That means we will not get it auto turn on when we enter one of the following program mode

  =:init= before trigger
  =:config= after trigger

  #+begin_src emacs-lisp
    (use-package smartparens
      :defer 0
      :commands (smartparens-mode)
      :hook
      (js-mode . smartparens-mode)
      (go-mode . smartparens-mode)
      (rust-mode . (lambda () (sp-local-pair 'rust-mode "'" nil :actions nil)
                     (smartparens-mode))) ;;; don't pair lifetime specifiers
      (html-mode . smartparens-mode)
      (python-mode . smartparens-mode)
      (emacs-lisp-mode . smartparens-mode)
      :config
      (require 'smartparens-config))
  #+end_src

* yasnippet

  TODO: replace ivy with consult
  =(yas-reload-all)= will rebuild the snippets, This will be trigger when enable yas-xx-mode

  #+begin_src emacs-lisp
    (use-package yasnippet
      :defer 1
      :config
      (add-to-list 'yas-snippet-dirs (expand-file-name "snippets" home-dir))
      ;; (yas-global-mode 1)
      (yas-minor-mode 1))

    (use-package yasnippet-snippets
      :defer t
      :after yasnippet)

    (when (featurep 'consult)

      (defun consult-yasnippet--tmpl (&optional all-templates)
        (barf-if-buffer-read-only)
        (let* ((buffer-undo-list t) ; Prevent querying user (and showing previews) from updating the undo-history
               (candidates
                (consult-yasnippet--candidates
                 (if all-templates
                     (yas--all-templates (map-values yas--tables))
                   (yas--all-templates (yas--get-snippet-tables))))))
          (consult--read
           candidates
           :prompt "Choose a snippet: "
           :annotate (consult-yasnippet--annotate candidates)
           :lookup 'consult--lookup-cdr
           :require-match t
           :state (consult-yasnippet--preview)
           :category 'yasnippet)))

      (defun consult-yas (arg)
        (interactive "P")
        (let* ((template (consult-yasnippet--tmpl arg))
               (thing-start ())
               (thing-end ()))
          (yas-expand-snippet (yas--template-content template)
                              thing-start thing-end
                              (yas--template-expand-env template)))))
  #+end_src


* helpful
  make help description more readble
  #+begin_src emacs-lisp
    (use-package helpful
      :bind
      ([remap describe-command] . helpful-callable)
      ([remap describe-function] . helpful-function)
      ([remap describe-variable] . helpful-variable)
      ([remap describe-symbol] . helpful-symbol)
      ([remap describe-keymap] . helpful-varaible)
      ([remap describe-key] . helpful-key))
  #+end_src

* winum
  #+begin_src emacs-lisp
    (use-package winum
      :defer 0
      :config
      (winum-mode))
  #+end_src

* systemd

  encounter an *issue: Company backend ’t’ could not be initialized*
  #+begin_src emacs-lisp
    (use-package systemd
      :defer t)
  #+end_src

* flycheck mode
  #+begin_src emacs-lisp
    (use-package flycheck
      :commands (flycheck-mode)
      :init
      (add-hook 'prog-mode-hook 'flycheck-mode)
      (add-hook 'text-mode-hook 'flycheck-mode)
      (setq flycheck-highlighting-mode 'lines)
      (setq flycheck-indication-mode '())
      :config
      (add-hook 'org-src-mode-hook #'(lambda ()
                                      (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))))
  #+end_src

* json-mode & yaml-mode

  use =make-local-variable= to set buffer local variable.

  #+begin_src emacs-lisp
    (use-package json-mode
      :defer t)

    (use-package yaml-mode
      :defer t
      :mode (("\\.\\(yml\\|yaml\\)\\'" . yaml-mode)
             ("Procfile\\'" . yaml-mode))
      :init
      (add-hook 'yaml-mode-hook #'(lambda ()
                                    (set (make-local-variable 'tab-width) 2)
                                    (set (make-local-variable 'evil-shift-width) 2)
                                    (set (make-local-variable 'indent-line-function) 'my-yaml-indent-line)))
      :config
      ;; (with-eval-after-load 'evil
      ;;   (evil-define-key 'normal yaml-mode-map (kbd "=") 'yaml-indent-line))
      (with-eval-after-load 'flycheck
        (when (listp flycheck-global-modes)
          (add-to-list 'flycheck-global-modes 'yaml-mode))))
  #+end_src


** experiment tree-sitter

   tree-sitter requires emacs built with dynamic modules (due to c bindings library) supports.
   (functionp 'module-load)

   #+begin_src emacs-lisp
     (use-package tree-sitter
       :config
       (global-tree-sitter-mode))

     (use-package tree-sitter-langs
       :defer t
       :hook
       (tree-sitter-after-on . tree-sitter-hl-mode))
   #+end_src

   now tree sitter are builtin in emacs 29 but it's not matured.

   auto setup tree sitter inspired from
   https://github.com/renzmann/treesit-auto/blob/main/treesit-auto.el

   #+begin_src emacs-lisp :tangle no
     (use-package treesit
       :straight (:type built-in)
       :commands (treesit-install-language-grammar treesit-install-all-languages)
       :init
       (setq treesit-language-source-alist
             '((bash . ("https://github.com/tree-sitter/tree-sitter-bash"))
               (c . ("https://github.com/tree-sitter/tree-sitter-c"))
               (cpp . ("https://github.com/tree-sitter/tree-sitter-cpp"))
               (common-lisp "https://github.com/theHamsta/tree-sitter-commonlisp")
               (elisp "https://github.com/Wilfred/tree-sitter-elisp")
               (css . ("https://github.com/tree-sitter/tree-sitter-css"))
               (go . ("https://github.com/tree-sitter/tree-sitter-go"))
               (html . ("https://github.com/tree-sitter/tree-sitter-html"))
               (javascript . ("https://github.com/tree-sitter/tree-sitter-javascript"))
               (json . ("https://github.com/tree-sitter/tree-sitter-json"))
               (lua . ("https://github.com/Azganoth/tree-sitter-lua"))
               (make . ("https://github.com/alemuller/tree-sitter-make"))
               (ocaml . ("https://github.com/tree-sitter/tree-sitter-ocaml" "ocaml/src" "ocaml"))
               (python . ("https://github.com/tree-sitter/tree-sitter-python"))
               (php . ("https://github.com/tree-sitter/tree-sitter-php"))
               (tsx . ("https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src"))
               (typescript . ("https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript"))
               (ruby . ("https://github.com/tree-sitter/tree-sitter-ruby"))
               (rust . ("https://github.com/tree-sitter/tree-sitter-rust"))
               (sql . ("https://github.com/m-novikov/tree-sitter-sql"))
               (yaml "https://github.com/ikatyang/tree-sitter-yaml")
               (toml . ("https://github.com/tree-sitter/tree-sitter-toml"))
               (zig . ("https://github.com/GrayJack/tree-sitter-zig"))))
       :config
       (let ((langs (mapcar 'car treesit-language-source-alist)))
         (dolist (lang langs)
           (let ((ts-mode (intern (concat (symbol-name lang) "-ts-mode")))
                 (name-mode (intern (concat (symbol-name lang) "-mode"))))
             (if (and (fboundp ts-mode) (treesit-ready-p lang t))
                 (add-to-list 'major-mode-remap-alist `(,name-mode . ,ts-mode)))))))

     (defun treesit-install-all-languages ()
       "Install all languages specified by `treesit-language-source-alist'."
       (interactive)
       (let ((languages (mapcar 'car treesit-language-source-alist)))
         (dolist (lang languages)
           (let ((ts-mode (intern (concat (symbol-name lang) "-ts-mode")))
                 (name-mode (intern (concat (symbol-name lang) "-mode"))))

             (treesit-install-language-grammar lang)
             (message "`%s' parser was installed." lang)
             (sit-for 0.75)))))
   #+end_src

   #+begin_src emacs-lisp
     (use-package ts-fold
       :after (evil tree-sitter)
       :straight (ts-fold :type git :host github :repo "emacs-tree-sitter/ts-fold")
       :config
       (push '(block . (ts-fold-range-seq -1 1)) (alist-get 'python-mode ts-fold-range-alist))
       (add-to-list 'evil-fold-list
                    '((ts-fold-mode)
                      :toggle ts-fold-toggle
                      :open ts-fold-open
                      :close ts-fold-close
                      :open-rec ts-fold-open-recursively
                      :open-all ts-fold-open-all
                      :close-all ts-fold-close-all))
       (global-ts-fold-mode))
   #+end_src

   #+begin_src emacs-lisp
     (with-eval-after-load 'yaml
       (with-eval-after-load 'json
         (defun get-config-nesting-paths ()
           "Get out all the nested paths in a config file."
           (let* ((query (pcase major-mode
                           ('json-mode "(object (pair (string (string_content) @key) (_)) @item)")
                           ('yaml-mode "(block_mapping_pair (flow_node) @key (_)) @item")))
                  (root-node (tsc-root-node tree-sitter-tree))
                  (query (tsc-make-query tree-sitter-language query))
                  (matches (tsc-query-matches query root-node #'tsc--buffer-substring-no-properties))
                  (prev-node-ends '(0)) ;; we can get away with just end as the list is sorted
                  (current-key-depth '())
                  (item-ranges (seq-map (lambda (x)
                                          (let ((item (seq-elt (cdr x) 0))
                                                (key (seq-elt (cdr x) 1)))
                                            (list (tsc-node-text (cdr key))
                                                  (tsc-node-range (cdr key))
                                                  (tsc-node-range (cdr item)))))
                                        matches)))
             (mapcar (lambda (x)
                       (let* ((current-end (seq-elt (cadr (cdr x)) 1))
                              (parent-end (car prev-node-ends))
                              (current-key (car x)))
                         (progn
                           (if (> current-end parent-end)
                               (mapcar (lambda (x)
                                         (if (> current-end x)
                                             (progn
                                               (setq prev-node-ends (cdr prev-node-ends))
                                               (setq current-key-depth (cdr current-key-depth)))))
                                       prev-node-ends))
                           (setq current-key-depth (cons current-key current-key-depth))
                           (setq prev-node-ends (cons current-end prev-node-ends))
                           (list (reverse current-key-depth) (seq-elt (cadr x) 0)))))
                     item-ranges)))

         (defun imenu-config-nesting-path ()
           "Return config-nesting paths for use in imenu"
           (mapcar (lambda (x)
                     (cons (string-join (car x) ".") (cadr x)))
                   (get-config-nesting-paths)))

         (add-hook 'json-mode-hook (lambda () (setq imenu-create-index-function #'imenu-config-nesting-path)))
         (add-hook 'yaml-mode-hook (lambda () (setq imenu-create-index-function #'imenu-config-nesting-path)))))
   #+end_src

   #+begin_src emacs-lisp
     (defun json-get-path (current-node output)
       "Get path to json value at cursor position.  CURRENT-NODE is a tree-sitter-node.
     OUTPUT is parsed path list."
       (let* ((parent-node (tsc-get-parent current-node)))
         (if parent-node
           (progn
             (when (eq (tsc-node-type parent-node) 'array)
               (let ((index -1)
                     (cursor (tsc-make-cursor parent-node)))
                 (tsc-goto-first-child cursor)
                 (while (not (tsc-node-eq current-node (tsc-current-node cursor)))
                     (progn
                       (tsc-goto-next-sibling cursor)
                       (if (tsc-node-named-p (tsc-current-node cursor))
                         (progn
                           (setq index (+ index 1))))))
                 (setq output (push index output))))
             (when (eq (tsc-node-type current-node) 'pair)
                 (setq output (push (tsc-node-text (tsc-get-nth-child current-node 0)) output)))
             (json-get-path parent-node output))
           output)))

     (defun json-print-path-js ()
       "Copy json path in JavaScript format."
       (interactive)
       (let (json-path)
         (dolist (elt (json-get-path (tree-sitter-node-at-pos) '()) json-path)
           (when (stringp elt)
             (let* ((trimmed-elt (string-trim elt "\"" "\"")))
               (if (string-match-p "-" trimmed-elt)
                   (setq json-path (concat json-path "[" trimmed-elt "]"))
                 (setq json-path (concat json-path "." trimmed-elt)))))
           (when (numberp elt)
             (setq json-path (concat json-path "[" (number-to-string elt) "]"))))
         (message json-path)
         (kill-new json-path)))

   #+end_src

* cmake
  #+begin_src emacs-lisp
    (use-package cmake-mode
      :defer t
      :mode (("CMakeLists\\.txt\\'" . cmake-mode) ("\\.cmake\\'" . cmake-mode)))
  #+end_src

* lua
  #+begin_src emacs-lisp
    (use-package lua-mode
      :mode (("\\.lua\\'" . lua-mode))
      :defer t)
  #+end_src

* calibre

  #+begin_src emacs-lisp
    (use-package calibredb
      :defer t
      :config
      (setq calibredb-format-all-the-icons t)
      (setq calibredb-root-dir "~/OneDrive/calibre")
      (setq calibredb-db-dir (expand-file-name "metadata.db" calibredb-root-dir)))
  #+end_src

* common lisp or emacs lisp

  TODO: maybe I neeed the better go to definition function like the spacemacs's implementation

  #+begin_src emacs-lisp
    (use-package slime
      :defer t
      :init
      (setq inferior-lisp-program "sbcl"))

    (use-package elisp-slime-nav
      :defer t
      :init
      (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
        (add-hook hook 'elisp-slime-nav-mode)))

    (use-package lispy
      :init
      (setq lispy-key-theme '(special c-digits))
      :custom
      (lispy-x-default-verbosity 1)
      :hook ((common-lisp-mode . lispy-mode)
             (emacs-lisp-mode . lispy-mode)
             (scheme-mode . lispy-mode))
      :config
      (with-eval-after-load 'evil-matchit
        (lispy-define-key lispy-mode-map (kbd "%") 'lispy-different)
        (lispy-define-key lispy-mode-map (kbd "d") 'lispy-kill)))

  #+end_src

* rust mode
  #+begin_src emacs-lisp
    (use-package rust-mode
      :defer t
      :mode "\\.rs\\'"
      :init (setq rust-format-on-save t))

    (use-package cargo
      :defer t)

  #+end_src

* dumb-jump

  a jump to definition with search tool (ag, rg)

  #+begin_src emacs-lisp
    (defvar-local dumb-temp-search-directory nil)

    (defun my-dumb-jump-get-project-root (filepath)
      "a very hack way to customize the way to search the project of dumb-jump"
      (let ((search-directory (or dumb-temp-search-directory
                                  (if (project-current nil)
                                  (project-root (project-current nil))
                                (read-directory-name "Start from directory: ")))))
        (setq-local dumb-temp-search-directory search-directory)
        search-directory))

    (advice-add 'dumb-jump-get-project-root :override #'my-dumb-jump-get-project-root)

    (use-package dumb-jump
      :init
      (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
      :custom
      (dumb-jump-selector 'completing-read)
      (dumb-jump-prefer-searcher 'rg)
      (dumb-jump-force-searcher 'rg)
      :defer t)
  #+end_src

* language server protocol mode

  run =company-diag= to check what the company-backend is being used.
  =(setq lsp-keymap-prefix "SPC m")= this will only affect the display info of whichkey.

  #+begin_src emacs-lisp

    (defun get-xref-find-backends ()
      (let (backends
            backend)
        (dolist (f xref-backend-functions)
          (when (functionp f)
            (setq backend (funcall f))
            (when backend
              (cl-pushnew (funcall f) backends))))
        (reverse backends)))

    (defun my-xref--create-fetcher (input kind arg)
      "Return an xref list fetcher function.

    It revisits the saved position and delegates the finding logic to
    the xref backend method indicated by KIND and passes ARG to it."
      (let* ((orig-buffer (current-buffer))
             (orig-position (point))
             (backends (get-xref-find-backends))
             (method (intern (format "xref-backend-%s" kind))))
        (lambda ()
          (save-excursion
            ;; Xref methods are generally allowed to depend on the text
            ;; around point, not just on their explicit arguments.
            ;;
            ;; There is only so much we can do, however, to recreate that
            ;; context, given that the user is free to change the buffer
            ;; contents freely in the meantime.
            (when (buffer-live-p orig-buffer)
              (set-buffer orig-buffer)
              (ignore-errors (goto-char orig-position)))
            (let (xrefs)
              (cl-dolist (backend backends)
                (ignore-errors
                  (setq xrefs (funcall method backend arg))
                  (when xrefs
                    (cl-return))))
              (unless xrefs
                (xref--not-found-error kind input))
              xrefs)))))



  #+end_src

  TODO: deprecate lsp, I decide to adopt elgot.

  #+begin_src emacs-lisp :tangle no
    (use-package lsp-bridge
      :defer t
      :straight (:host github :repo "manateelazycat/lsp-bridge" :files ("*.el" "")))
  #+end_src

  #+begin_src emacs-lisp

    (use-package eglot
      :defer t
      :init
      (setq read-process-output-max (* 1024 1024))
      :hook
      ;; (python-ts-mode . eglot-ensure)
      (rust-mode . eglot-ensure)
      (rust-ts-mode . eglot-ensure)
      (lua-mode . eglot-ensure)
      (dart-mode . eglot-ensure)
      (js-mode . eglot-ensure)
      (js-ts-mode . eglot-ensure)
      (typescript-ts-mode . eglot-ensure)
      (typescript-mode . eglot-ensure)
      (json-mode . eglot-ensure) ;; npm i -g vscode-langservers-extracted
      (json-ts-mode . eglot-ensure)
      (yaml-mode . eglot-ensure) ;; brew install yaml-language-server
      (yaml-ts-mode . eglot-ensure)
      (go-mode . eglot-ensure)
      (go-ts-mode . eglot-ensure)
      :custom
      (eglot-stay-out-of '(xref imenu)) ;; imenu in go-mode will cause jsonrpc timeout
      (enable-local-variables nil)
      (xref-search-program 'ripgrep)
      (eglot-events-buffer-size 0)
      (eglot-ignored-server-capabilities '(:hoverProvider
                                           :documentHighlightProvider))
      :config
      (advice-add #'xref--create-fetcher :override #'my-xref--create-fetcher)
      ;; this make evil go to definition works normally like xref-find-definitions
      (setq xref-prompt-for-identifier (append xref-prompt-for-identifier '(evil-goto-definition)))
      (add-hook 'python-mode-hook (lambda ()
                                    (when-let ((venv-path (python-find-virtualenv)))
                                      (setq-default eglot-workspace-configuration
                                                    `(:python.analysis
                                                      (:stubPath
                                                       ""
                                                       :useLibraryCodeForTypes
                                                       t
                                                       :autoSearchPaths
                                                       t
                                                       :autoImportCompletions
                                                       t
                                                       :diagnosticMode
                                                       "openFilesOnly")
                                                      :python
                                                      (:venvPath
                                                       ,(file-name-directory venv-path)
                                                       :venv
                                                       ,(file-name-nondirectory venv-path)
                                                       :pythonPath
                                                       ,(concat venv-path "/bin/python"))))

                                      (when (featurep 'eglot)
                                        (flycheck-mode -1)
                                        (eglot-ensure)
                                        (add-hook 'xref-backend-functions 'dumb-jump-xref-activate nil t)
                                        (add-hook 'xref-backend-functions 'eglot-xref-backend nil t)))))

      (add-hook 'eglot--managed-mode-hook #'(lambda () (add-hook 'xref-backend-functions 'eglot-xref-backend nil t)))
      (add-to-list 'eglot-server-programs '(python-mode . ("pyright-langserver" "--stdio")))
      (add-to-list 'eglot-server-programs '(rust-mode . ("rustup" "run" "stable" "rust-analyzer"))))
  #+end_src


* wgrep mode
  #+begin_src emacs-lisp
    (use-package wgrep
      :after evil
      :commands
      (wgrep-finish-edit
       wgrep-finish-edit
       wgrep-abort-changes
       wgrep-abort-changes)
      :init
      (evil-define-key 'normal wgrep-mode-map (kbd "<escape>") 'wgrep-exit)
      (evil-define-key 'normal wgrep-mode-map (kbd ", ,") 'wgrep-finish-edit)
      (evil-define-key 'normal wgrep-mode-map (kbd ", k") 'wgrep-abort-changes))
  #+end_src

* multiple-cursors
  it will save the command behavior applied on the multiple cursor to a file named .mc-lists.el.
  By default, it's path is =~/.emacs.d/.mc-lists.el= and I customize the storing path already.
  Research how evil-mc customize the multiple-cursor

  https://github.com/magnars/multiple-cursors.el#unknown-commands

  #+begin_src emacs-lisp
    (use-package multiple-cursors
      :custom
      (mc/always-run-for-all t)
      :commands
      (mc/edit-lines
       mc/mark-all-like-this
       mc/add-cursor-on-click
       mc/mark-next-like-this
       mc/mark-previous-like-this))

    (use-package evil-mc
      :after evil
      :config
      (global-evil-mc-mode 1))
  #+end_src

  #+begin_src emacs-lisp
    (use-package iedit
      :commands
      (iedit-restrict-region)
      :config
      (define-key iedit-occurrence-keymap-default
        (kbd "<escape>") #'(lambda () (interactive) (iedit-mode -1))))
  #+end_src

* auto-highlight-symbol

  Only the mode appears in the =ahs-plugin-bod-modes= can use beginning of the defun plugin

  #+begin_src emacs-lisp
    (use-package auto-highlight-symbol
      :commands
      (ahs-forward
       ahs-unhighlight
       ahs-unhighlight-all
       ahs-change-range
       ahs-change-range-internal
       ahs-dropdown-list-p
       ash-backward)
      :config
      (setq ahs-case-fold-search nil)
      (add-to-list 'ahs-plugin-bod-modes 'python-mode))
  #+end_src

* general

  provide a spacemacs leader like ux.

  #+begin_src emacs-lisp
    (use-package general
      :after (which-key evil)
      :config
      (defconst leader-key "SPC")
      (defconst major-mode-leader-key "SPC m")
      (defconst major-mode-leader-key-shortcut ",")
      (defconst emacs-state-leader-key "M-m")
      (defconst emacs-state-major-mode-leader-key "M-m m")

      (setq my-leader-def-prop
            '(:key leader-key :states (normal visual motion)))

      (setq my-leader-def-emacs-state-prop
            '(:key emacs-state-leader-key :state (emacs)))

      ;; below are for major mode
      (setq my-local-leader-def-prop
            '(:key major-mode-leader-key :states (normal visual motion)))

      (setq my-local-leader-def-alias-prop
            '(:key major-mode-leader-key-shortcut :states (normal visual motion)))

      (setq my-local-leader-def-emacs-state-prop
            '(:key emacs-state-major-mode-leader-key :states (emacs)))
      ;; NOTE: '() the element inside will be symbol

      ;; NOTE: keysmaps override is to make general-define-key to be global scope
      ;; No need to set this one (evil-make-overriding-map dired-mode-map 'normal)
      (message "DEBUG: !! general init")

      (with-eval-after-load 'emmet-mode
        (evil-define-key 'insert emmet-mode-keymap (kbd "TAB") 'my-emmet-expand))

      ;; unbind some keybinding in the package 'evil-org
      (with-eval-after-load 'evil-org
        ;;  org-agenda-redo
        ;;  make org agenda enter the motion state
        ;;  I don't the original state
        (evil-set-initial-state 'org-agenda-mode 'motion)
        ;; TODO: research about this evilified-state-evilify-map

        (evil-define-key 'motion org-agenda-mode-map
          (kbd "j") 'org-agenda-next-line
          "t" 'org-agenda-todo
          "I" 'org-agenda-clock-in          ; Original binding
          "O" 'org-agenda-clock-out         ; Original binding
          (kbd "<return>") 'org-agenda-goto
          (kbd "k") 'org-agenda-previous-line
          (kbd "s") 'org-save-all-org-buffers))

      (with-eval-after-load 'org

        ;; define key open-thing-at-point with enter
        (evil-define-key 'normal org-mode-map (kbd "<return>") 'org-open-at-point)
        (evil-define-key 'normal prog-mode-map (kbd "<return>") 'org-open-at-point))

      (with-eval-after-load 'org-capture
        (evil-define-key 'normal org-capture-mode-map
          (kbd ", ,") 'org-capture-finalize
          (kbd ", k") 'org-capture-kill
          (kbd ", w") 'org-capture-refile))

      ;; add shortcuts for org src edit mode
      (with-eval-after-load 'org-src
        (evil-define-key 'normal org-src-mode-map
          (kbd ", ,") 'org-edit-src-exit
          (kbd ", k") 'org-edit-src-abort))

      (with-eval-after-load 'with-editor
        (evil-define-key 'normal with-editor-mode-map
          (kbd ", ,") 'with-editor-finish
          (kbd ", k") 'with-editor-cancel))

      (evil-define-key 'visual 'global
        (kbd "g y") 'copy-region-and-base64-decode
        (kbd "g e") 'copy-region-and-urlencode)


      ;; keybinding for racket-mode
      (with-eval-after-load 'racket-mode
        (define-leader-key-map-for 'racket-mode
                                   "" "major mode" nil
                                   "x" "execute" nil
                                   "xx" "racket run" 'racket-run))

      ;; keybindings for some major modes
      ;; NOTE: consider to move these to the configuration of each major-mode?

      ;; keybinding for go-mode
      (with-eval-after-load 'go-mode

        (define-leader-key-map-for 'go-mode-map
                                   "" "major mode" nil
                                   "x" "execute" nil
                                   "xx" "go run" 'go-run-main
                                   "d" "debug" 'dap-hydra
                                   "e" "gomacro" 'gomacro-run)


        (evil-define-key 'normal go-mode-map (kbd "K") 'evil-smart-doc-lookup))

      (with-eval-after-load 'rust-mode

        (evil-define-key 'normal rust-mode-map (kbd "K") 'evil-smart-doc-lookup))

      ;; keybinding for python-mode
      (with-eval-after-load 'python

        (apply 'define-leader-key-map-for
               (list 'python-mode-map
                     "" "major mode" '()

                     "x" "execute" nil
                     "xx" "python run" 'python-run-main
                     "h" "help" 'eldoc-box-eglot-help-at-point
                     "v" "workon env" 'workon-virtual-env-and-lsp
                     "d" "debug" 'dap-hydra)))

      (with-eval-after-load 'json-mode
        (define-leader-key-map-for 'json-mode-map
                                   "" "major mode" nil
                                   "l"  "lookup" nil
                                   "ll" "snatch path" 'json-print-path-js
                                   "lj" "jq" 'consult-jq))


      (with-eval-after-load 'yaml-mode
        (define-leader-key-map-for 'yaml-mode-map
                                   "" "major mode" nil
                                   "l" "lookup" nil
                                   "ly" "yq" 'consult-yq))


      (with-eval-after-load 'elisp-mode
        (define-leader-key-map-for 'emacs-lisp-mode-map
                                   "" "major mode" nil
                                   "e" "eval" nil
                                   "ef" "eval defun" 'eval-defun
                                   "eb" "eval buffer" 'eval-buffer
                                   "er" "eval region" 'eval-region ))

      (with-eval-after-load 'org
        (define-leader-key-map-for 'org-mode-map
                                   "" "major mode" nil

                                   "a" "org-agenda" 'org-agenda
                                   "," "org-ctrl-c-ctrl-c" 'org-ctrl-c-ctrl-c
                                   "'" "org-edit-special" 'org-edit-special

                                   "b" "babel" nil
                                   "bt" "tangle" 'org-babel-tangle

                                   "i" "insert" nil
                                   "il" "insert link" 'org-insert-link
                                   "it" "insert toc" 'org-insert-toc

                                   "e" "export" nil
                                   "ee" "org-export-dispatch" 'org-export-dispatch

                                   "n" "narrow" nil
                                   "ns" "narrow subtree" 'org-narrow-to-subtree
                                   "nN" "widen" 'widen

                                   "r" "org roam hydra" 'hydra-org-roam/body

                                   "s" "schedule" nil
                                   "ss" "org-schedule" 'org-schedule
                                   "sd" "org-deadline" 'org-deadline
                                   "st" "org-time-stamp" 'org-time-stamp

                                   "d" "org-download" nil
                                   "dc" "from clipboard" 'org-download-clipboard
                                   "ds" "from screenshot" 'org-download-screenshot

                                   "t" "toggles" nil
                                   "tl" "link display" 'org-toggle-link-display
                                   "ti" "inline image" 'org-toggle-inline-images

                                   "j" "journals" nil
                                   "jn" "new entry" 'org-journal-new-entry
                                   "js" "new stock entry" #'(lambda () (interactive) (create-journal-to "~/Dropbox/myorgs/stock/journal"))))


      (define-leader-key-global
       "SPC" 'execute-extended-command
       "/" 'my-project-rg
       "v" 'er/expand-region
       "u" 'universal-argument
       "'" 'new-terminal
       "TAB" 'vterm-perform-last-command
       "?" 'describe-bindings)

      ;; which-key-replacement-alist
      ;; change the content of the above variable
      (define-leader-key-global
       "1" 'winum-select-window-1
       "2" '(winum-select-window-2 :which-key t)
       "3" '(winum-select-window-3 :which-key t)
       "4" '(winum-select-window-4 :which-key t)
       "5" '(winum-select-window-5 :which-key t)
       "6" '(winum-select-window-6 :which-key t)
       "7" '(winum-select-window-7 :which-key t)
       "8" '(winum-select-window-8 :which-key t)
       "9" '(winum-select-window-9 :which-key t))

      ;; need to find a way to add which-key hints
      ;; for the following window selection
      (push '(("\\(.*\\)1" . "winum-select-window-1") .
              ("\\11..9" . "select window 1..9"))
            which-key-replacement-alist)

      (define-leader-key-global
       "j" '(:ignore t :which-key "jump")
       "jw" '(avy-goto-char-timer :which-key "avy goto words")
       "ju" '(avy-jump-url :which-key "goto url")
       "jd" '(dumb-jump-go :which-key "goto definition") ;; limit the search area with the project root
       "jl" '(avy-goto-line :which-key "goto line")
       "ji" '(jump-in-buffer :which-key "imenu")
       "j(" '(check-parens :which-key "check-parens"))

      (define-leader-key-global
       "r" '(:ignore t :which-key "resume/register")
       "rk" '(consult-yank-pop :which-key "kill ring")
       "re" '(consult-register :which-key "evil register")

       "rm" '(:ignore t :which-key "mark ring")
       "rml" '(consult-mark :which-key "local mark ring")
       "rmg" '(consult-global-mark :which-key "global mark ring")

       "rl" '(vertico-repeat :which-key "minibuffer-resume"))

      (define-leader-key-global
       "a" '(:ignore t :which-key "applications")

       "ad" '(docker t :which-key "docker")

       "al" '(:ignore t :which-key "lookup/dictionary")
       "ald" '(define-word :which-key "lookup definition")
       "alg" '(google-search :which-key "google search")
       "alx" '(open-with-xwidget :which-key "open with xwidget")

       "ao" '(:ignore t :which-key "org")
       "aor" '(hydra-org-roam/body :which-key "org-roam-hydra")
       "aog" '(:ignore t :which-key "goto")
       "aogj" '((lambda () (interactive) (find-file (expand-file-name "~/Dropbox/myorgs/journal"))) :which-key "journal note")
       "aogt" '((lambda () (interactive) (org-file-show-headings "~/Dropbox/myorgs/life_books_courses_programming/todo.org")) :which-key "todo note"))

      (define-leader-key-global
       "b" '(:ignore t :which-key "buffer")
       "bb" '(consult-project-buffer :which-key "project-list-buffer")
       "bd" '(kill-this-buffer :which-key "kill-buffer")
       "bB" '(consult-buffer :which-key "list-buffer")
       "bi" '(ibuffer :which-key "ibuffer")
       "bn" '(next-buffer :which-key "next-buffer")
       "bp" '(previous-buffer :which-key "previous-buffer")
       "bN" '(new-empty-buffer :which-key "new empty buffer")
       "b." '(buffer-operate/body :which-key "buffer transient"))

      (define-leader-key-global
       "c" '(:ignore t :which-key "comment/compile")
       "cl" '(comment-or-uncomment-lines :which-key "comment or uncomment"))

      (define-leader-key-global
       "e" '(:ignore t :which-key "errors")
       "el" '(toggle-flycheck-error-list :which-key "flycheck error list"))


      (define-leader-key-global
       "i" '(:ignore t :which-key "insert")
       "is" '(insert-yas :which-key "snippets"))

      (define-leader-key-global
       "l" '(:ignore t :which-key "layout")
       "ll" '(persp-switch :which-key "switch layout")
       "lr" '(persp-rename :which-key "rename layout")
       "ld" '(persp-kill :which-key "delete layout")
       "lb" '(persp-switch-to-buffer* :which-key "persp buffer list"))

      (define-leader-key-global
       "n" '(:ignore t :which-key "narrow")
       "nf" '(narrow-to-defun :which-key "narrow to defun")
       "nr" '(narrow-to-region :which-key "narrow to region")
       "nw" '(widen :which-key "widen"))

      (define-leader-key-global
       "p" '(:ignore t :which-key "project")
       "pp" '(consult-switch-project :which-key "switch project")
       "pf" '(project-find-file :which-key "find-file"))

      (define-leader-key-global
       "s" '(:ignore t :which-key "search")
       "sc" '((lambda () (interactive) (evil-ex-nohighlight)(ahs-clear)) :which-key "clear highlight")
       "ss" '(consult-line :which-key "consult-line")
       "sS" '(consult-line-multi :which-key "consult-line-all"))

      (define-leader-key-global
       "g" '(:ignore t :which-key "git")
       "gi" '(magit-init :which-key "gagit init")
       "gb" '(:ignore t :which-key "blame")
       "gl" '(magit-list-repositories :which-key "magit list repos")
       "gbl" '(git-messenger:popup-message  :which-key "this line")
       "gbb" '(magit-blame-addition  :which-key "this buffer")
       "gs" '(magit-status :which-key "magit status"))

      (define-leader-key-global
       "k" '(:ignore t :which-key "kmacro")
       "ks" '(kmacro-start-macro-or-insert-counter :which-key "start macro/insert counter")
       "ke" '(kmacro-end-or-call-macro :which-key "end or run record")
       "kv" '(kmacro-view-macro-repeat :which-key "view last macro")
       "kn" '(kmacro-name-last-macro :which-key "name the last kmacro"))

      (define-leader-key-global
       "q" '(:ignore t :which-key "quit")
       "qq" '(save-buffers-kill-emacs :which-key "quit with saving buffer")
       "qr" '(restart-emacs :which-key "restart"))

      (define-leader-key-global
       "t"  '(:ignore t :which-key "toggles")
       "tm" '(hydra-mode-toggle/body :which-key "toggle mode")
       "ti" '(toggle-input-method :which-key "toggle input method")
       "ts" '(hydra-text-scale/body :which-key "scale text"))

      (define-leader-key-global
       "w" '(:ignore t :which-key "windows")
       "wf" '(toggle-frame-fullscreen :which-key "toggle fullscreen")
       "ww" '(other-window :which-key "other-window")
       "wm" '(toggle-maximize-buffer :which-key "window maximized")
       "wM" '(toggle-frame-maximized :which-key "frame maximized")
       "wd" '(delete-window :which-key "delete window")
       "wh" '(evil-window-left :which-key "go to window left")
       "wl" '(evil-window-right :which-key "go to window right")
       "wk" '(evil-window-up :which-key "go to window up")
       "wr" '(rotate-windows-forward :which-key "rotate window")
       "wj" '(evil-window-down :which-key "go to window down")
       "wL" '(evil-window-move-far-right :which-key "move window to right side")
       "wH" '(evil-window-move-far-left :which-key "move window to left side")
       "wJ" '(evil-window-move-very-bottom :which-key "move window to bottom side")
       "wK" '(evil-window-move-very-top :which-key "move window to top side")

       "wg" '(switch-to-minibuffer-window :which-key "go to minibuffer")

       "w/" '(evil-window-vsplit :which-key "split vertically")
       "w-" '(evil-window-split :which-key "split horizontally")

       "w=" '(balance-windows :which-key "balance")
       "w[" '(my-shrink-window-horizontally :which-key "shrink h")
       "w]" '(my-enlarge-window-horizontally :which-key "enlarge h")
       "w{" '(my-shrink-window :which-key: "shrink v")
       "w}" '(my-enlarge-window :which-key: "enlarge v")

       "wF" '(make-frame :which-key "make frame")
       "wD" '(delete-frame :which-key "delete frame")
       "wo" '(other-frame :which-key "other frame")
       "w." '(window-operate/body :which-key "window transient"))

      (define-leader-key-global
       "x" '(:ignore t :which-key "texts")
       "xc" '(count-words-region :which-key "count-words-region")

       "xb" '(:ignore t :which-key "base64")
       "xbe" '(my-encode-region-base64 :which-key "base64-encode-region")
       "xbd" '(my-decode-region-base64 :which-key "base64-decode-region")

       "xs" '(send-text-and-move-to-project-vterm :which-key "send content to and focus on vterm"))

      (define-leader-key-global
       "f" '(:ignore t :which-key "files")
       "fe" '(:ignore t :which-key "emacs")
       "fed" '(my-find-dotfile :which-key "open config dotfile")
       "fy" '(copy-file-path :which-key "copy file path")
       "fd" '(dired-jump :which-key "dired")
       "fs" '(save-buffer :which-key "save file")
       "fr" '(rename-current-buffer-file :which-key "rename file")
       "ff" '(find-file :which-key "find file"))

      (message "DEBUG: !! complete general setting"))
  #+end_src

* hydra

** hydra doc rule

   it seems need to add =\n= at the beginning and end of docstring.
   TODO: to understand the hydra's doc rule.

   %`[elisp variable]
   %([elisp function])

   #+begin_example
     ^Resize^
     ^^^^────
     _[_ : a
     _]_ : b
     _{_ : c
     _}_ : d
     _=_ : f
   #+end_example

** hydra motion

   #+begin_src emacs-lisp
     (use-package hydra
       :defer t)

     (defhydra window-operate ()
       "
     Window management :)
     ^Resize^                ^select^                         ^Move^          ^Action^
     ^───────────────^       ^────────^                       ^────────^      ^────────^
     [_[_] : shrink h        [_h_]: left                      [_H_]: left       [_/_]: split vertically
     [_]_] : enlarge h       [_l_]: right                     [_L_]: right      [_-_]: split horizontally
     [_{_] : shrink v        [_k_]: up                        [_K_]: up         [_d_]: delete window
     [_}_] : enlarge v       [_j_]: down                      [_J_]: down
     [_=_] : balance         [_1_.._9_]: window 1..9
     [_m_] : window maximize
     "
       ("[" my-shrink-window-horizontally nil)
       ("]" my-enlarge-window-horizontally nil)
       ("{" my-shrink-window nil)
       ("}" my-enlarge-window nil)
       ("=" balance-windows nil)
       ("d" delete-window nil)
       ("m" toggle-maximize-buffer nil)
       ("h" evil-window-left nil)
       ("l" evil-window-right nil)
       ("k" evil-window-up nil)
       ("j" evil-window-down nil)
       ("r" rotate-windows-forward nil)
       ("L" evil-window-move-far-right nil)
       ("H" evil-window-move-far-left nil)
       ("J" evil-window-move-very-bottom nil)
       ("K" evil-window-move-very-top nil)
       ("/" evil-window-vsplit nil)
       ("-" evil-window-split nil)

       ("1" winum-select-window-1 nil)
       ("2" winum-select-window-2 nil)
       ("3" winum-select-window-3 nil)
       ("4" winum-select-window-4 nil)
       ("5" winum-select-window-5 nil)
       ("6" winum-select-window-6 nil)
       ("7" winum-select-window-7 nil)
       ("8" winum-select-window-8 nil)
       ("9" winum-select-window-9 nil))

     (defhydra hydra-org-roam (:exit t)
       "Launcher for `org-roam'."
       ("a" org-roam-alias-add "add alias for node")
       ;; this is used for whening the name is conflict. It mostly happens in the header name
       ("c" org-id-get-create "create node")
       ("i" org-roam-node-insert "insert")
       ("f" org-roam-node-find "find file")
       ("d" org-roam-dailies-goto-today "dailies")
       ("l" org-roam-buffer-toggle "back link buffer")
       ("g" my-org-roam-ui-open "graph")
       ("r" my-refresh-org-roam-db-cache "db refresh")
       ("t" org-roam-tag-add "add tag"))


     (defhydra buffer-operate ()
       "
     buffer management :)
     ^Move^                         ^action^
     ^────────^                     ^───────^
     [_n_] : next buffer            [_d_] : delete
     [_p_] : prev buffer
     [_b_] : project buffers
     [_B_] : buffers list
     [_o_] : other window
     "

       ("n" next-buffer nil)
       ("p" previous-buffer nil)
       ("b" consult-project-buffer nil)
       ("B" consult-buffer nil)
       ("o" other-window nil)
       ("d" kill-this-buffer nil))

     (defhydra hydra-text-scale (:timeout 8)
       "scale text"
       ("j" text-scale-increase "+")
       ("k" text-scale-decrease "-")
       ("0" ((lambda (inc) (text-scale-adjust inc)) 0) "reset")
       ("<escape>" nil "finished" :exit t))

     (defhydra hydra-mode-toggle ()
       "toggle mode"
       ("r" rainbow-mode "rainbow mode")
       ("w" whitespace-mode "whitespace-mode")
       ("t" consult-theme "theme")
       ("v" visual-line-mode "visual line mode")
       ("f" flyspell-mode "check spell"))

     (defhydra hydra-table-mode ()
       "table-mode edit shortcut"
       ("+" table-insert-row-column "insert new row/column")
       ("*" table-span-cell "merge cell")
       (":" table-justify "align cell")
       ("-" table-split-cell-vertically "cell split horizontally")
       ("/" table-split-cell-horizontally "cell split vertically")
       ("<" table-narrow-cell "narrow cell")
       (">" table-widen-cell "widen cell")
       ("{" table-shorten-cell "shorten cell")
       ("}" table-heighten-cell "heighten cell"))
   #+end_src

   Originally, evil defines key =*= in motion-state with =evil-search-forward=

   #+begin_src emacs-lisp
     (setq ahs-default-range 'ahs-range-whole-buffer)

     (defun my-ahs-highlight-p ()
       "Ruturn Non-nil if symbols can be highlighted."
       (interactive)
       (let* ((beg (if (region-active-p) (region-beginning) (overlay-start ahs-current-overlay)))
              (end (if (region-active-p) (region-end) (overlay-end ahs-current-overlay)))
              (face (get-text-property beg 'face))
              (symbol (buffer-substring beg end)))

         (ahs-unhighlight t)
         (when (and symbol
                    (not (ahs-dropdown-list-p))
                    ;; (not (ahs-face-p (ahs-add-overlay-face beg face) 'ahs-inhibit-face-list))
                    ;; disable skip highlight for some font-face
                    (not (ahs-symbol-p ahs-exclude symbol t))
                    (ahs-symbol-p ahs-include symbol))
           (list symbol beg end))))

     (defun my-ahs-search-symbol (symbol search-range)
       "Search `SYMBOL' in `SEARCH-RANGE'."
       (save-excursion
         (let ((case-fold-search ahs-case-fold-search)
               ;; (regexp (concat "\\_<\\(" (regexp-quote symbol) "\\)\\_>" ))
               (regexp (regexp-quote symbol))
               (beg (car search-range))
               (end (cdr search-range)))
           (goto-char end)
           (while (re-search-backward regexp beg t)
             (let* ((symbol-beg (match-beginning 0))
                    (symbol-end (match-end 0))
                    (tprop (text-properties-at symbol-beg))
                    (face (cadr (memq 'face tprop)))
                    (fontified (cadr (memq 'fontified tprop))))
               (unless (or face fontified)
                 (setq ahs-need-fontify t))
               (push (list symbol-beg
                           symbol-end
                           face fontified) ahs-search-work))))))


     (defun my-ahs-light-up (current)
       "Light up symbols."
       (cl-loop for symbol in ahs-search-work

                for beg = (nth 0 symbol)
                for end = (nth 1 symbol)
                for face = (or (nth 2 symbol)
                               (get-text-property beg 'face))
                for face = (ahs-add-overlay-face beg face)

                do (let ((overlay (make-overlay beg end nil nil t)))
                     (overlay-put overlay 'ahs-symbol t)
                     (overlay-put overlay 'window (selected-window))
                     (overlay-put overlay 'face
                                  (if (ahs-face-p face 'ahs-definition-face-list)
                                      (if current ahs-definition-face
                                        ahs-definition-face-unfocused)
                                    (if current ahs-face ahs-face-unfocused)))
                     (push overlay ahs-overlay-list))))

     (advice-add 'ahs-light-up :override #'my-ahs-light-up)
     (advice-add 'ahs-highlight-p :override #'my-ahs-highlight-p)
     (advice-add 'ahs-search-symbol :override #'my-ahs-search-symbol)

     (defun expand-and-highlight-region ()
       (interactive)
       (er--expand-region-1)
       (highlight-region))

     (defun contract-and-highlight-region ()
       (interactive)
       (call-interactively 'er/contract-region)
       (highlight-region))


     (defun highlight-region ()
       (interactive)
       (let ((hh (my-ahs-highlight-p)))
         (unless ahs-current-range
           (ahs-change-range-internal ahs-default-range))
         (when hh
           (ahs-highlight (nth 0 hh)
                          (nth 1 hh)
                          (nth 2 hh)))))


     (defun evil-surround-region-utils (operation)
       ;; TODO: implement this one
       (interactive (evil-surround-interactive-setup))
       ;; (cond
       ;;  ((eq operation 'change)
       ;;   (call-interactively 'evil-surround-change))
       ;;  ((eq operation 'delete)
       ;;   (call-interactively 'evil-surround-delete))
       ;;  (t
       ;;   (evil-surround-setup-surround-line-operators)
       ;;   (evil-surround-call-with-repeat 'evil-surround-region))))

       (if (region-active-p)
           (evil-surround-setup-surround-line-operators)
         (evil-surround-call-with-repeat 'evil-surround-region)))


     (defhydra mark-operation ()
       "\nSwift knife %s(propertize (format \" %s \" (ahs-current-plugin-prop 'name)) 'face  (ahs-current-plugin-prop 'face))

     ^match^                   ^Search^                       ^edit^                        ^operation^
     ^^^─────────────────────────────────────────────────────────────────────────────────────────────────────────
     [_v_]: expand             [_s_]: consult-line            [_e_]: iedit                  [_t_]: send to vterm
     [_-_]: contract           [_/_]: project-rg              [_h_]: highlight
     [_r_]: range              ^ ^                            [_c_]: change surround
     [_n_]: next
     [_N_]: prev
     [_<escape>_]: quit
     "

       ("<escape>" (lambda ()(interactive) (ahs-unhighlight-all t)) nil :exit t)
       ("v" expand-and-highlight-region nil)
       ("-" contract-and-highlight-region nil)
       ("s" consult-line nil)
       ("c" evil-surround-region nil)
       ("/" my-project-rg nil)
       ("e" my-iedit-mode nil :exit t)
       ("h" highlight-region nil)
       ("r" my-change-range nil)
       ("l" google-search)
       ("t" send-text-and-move-to-project-vterm nil :exit t)
       ("n" my-ahs-forward nil)
       ("N" my-ahs-backward nil))

     (defun my-iedit-mode ()
       (interactive)
       (ahs-unhighlight-all)
       (call-interactively 'iedit-mode)
       (iedit-restrict-region
        (ahs-current-plugin-prop 'start)
        (ahs-current-plugin-prop 'end)))

     (defun my-change-range ()
       (interactive)
       (setq range (ahs-runnable-plugins t))
       (ahs-change-range-internal range)
       (if ahs-current-overlay
           (highlight-region))
       (iedit-restrict-region
        (ahs-current-plugin-prop 'start)
        (ahs-current-plugin-prop 'end)))

     (defun my-ahs-forward ()
       (interactive)
       (when (region-active-p)
         (deactivate-mark))
       (ahs-forward))

     (defun my-ahs-backward ()
       (interactive)
       (when (region-active-p)
         (deactivate-mark))
       (ahs-backward))

     (with-eval-after-load 'auto-highlight-symbol
       (add-to-list 'ahs-unhighlight-allowed-commands 'mark-operation/my-change-range)
       (add-to-list 'ahs-unhighlight-allowed-commands 'mark-operation/my-ahs-backward)
       (add-to-list 'ahs-unhighlight-allowed-commands 'mark-operation/my-project-rg)
       (add-to-list 'ahs-unhighlight-allowed-commands 'mark-operation/my-ahs-forward))

     (defun wrap-mark-operation ()
       (interactive)
       (unless (region-active-p)
         (er--expand-region-1))
       (highlight-region)
       (mark-operation/body))

     (with-eval-after-load 'evil
       (evil-define-key '(normal motion) 'evil-motion-state-map
         (kbd "*") 'wrap-mark-operation))
   #+end_src

* provide package

  #+begin_src emacs-lisp
    (provide 'jemacs-unarrange)
    ;;; jemacs-unarrange.el ends here
  #+end_src
